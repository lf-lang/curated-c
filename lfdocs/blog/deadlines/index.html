<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">Working with Deadlines | Lingua Franca</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://www.lf-lang.org/img/lf-social-card.png"><meta data-rh="true" name="twitter:image" content="https://www.lf-lang.org/img/lf-social-card.png"><meta data-rh="true" property="og:url" content="https://www.lf-lang.org/blog/deadlines/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Working with Deadlines | Lingua Franca"><meta data-rh="true" name="description" content="SensorProcessorActuator diagram"><meta data-rh="true" property="og:description" content="SensorProcessorActuator diagram"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2025-08-23T00:00:00.000Z"><meta data-rh="true" property="article:author" content="http://people.eecs.berkeley.edu/~eal/,https://www.linkedin.com/in/ravicakella/,https://dblp.org/pid/347/8232.html,https://github.com/keiichibando"><meta data-rh="true" property="article:tag" content="lingua franca,deadlines,real-time,scheduling"><link data-rh="true" rel="icon" href="../../img/favicon.png"><link data-rh="true" rel="canonical" href="https://www.lf-lang.org/blog/deadlines/"><link data-rh="true" rel="alternate" href="https://www.lf-lang.org/blog/deadlines/" hreflang="en"><link data-rh="true" rel="alternate" href="https://www.lf-lang.org/blog/deadlines/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://U5IWIJW31Z-dsn.algolia.net" crossorigin="anonymous"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://www.lf-lang.org/blog/deadlines","mainEntityOfPage":"https://www.lf-lang.org/blog/deadlines","url":"https://www.lf-lang.org/blog/deadlines","headline":"Working with Deadlines","name":"Working with Deadlines","description":"SensorProcessorActuator diagram","datePublished":"2025-08-23T00:00:00.000Z","author":[{"@type":"Person","name":"Edward A. Lee","description":"Professor at UC Berkeley","url":"http://people.eecs.berkeley.edu/~eal/","image":"https://avatars.githubusercontent.com/u/8513334?v=4"},{"@type":"Person","name":"Ravi Akella","description":"Sr. Research Engineer, DENSO International America Inc.","url":"https://www.linkedin.com/in/ravicakella/","image":"https://avatars.githubusercontent.com/u/913550?v=4"},{"@type":"Person","name":"Francesco Paladino","description":"Postdoc, UC Berkeley","url":"https://dblp.org/pid/347/8232.html","image":"https://avatars.githubusercontent.com/u/47446988?v=4"},{"@type":"Person","name":"Keiichi Bando","description":"Chief Engineer, DENSO Create Inc.","url":"https://github.com/keiichibando","image":"https://avatars.githubusercontent.com/u/149469685?v=4"}],"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://www.lf-lang.org/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="../rss.xml" title="Lingua Franca RSS Feed">
<link rel="alternate" type="application/atom+xml" href="../atom.xml" title="Lingua Franca Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Lingua Franca" href="../../opensearch.xml"><link rel="stylesheet" href="../../assets/css/styles.ba30d6af.css">
<script src="../../assets/js/runtime~main.cb523eb3.js" defer="defer"></script>
<script src="../../assets/js/main.0ff8ee1b.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="../../index.html"><div class="navbar__logo"><img src="../../img/lf-forlight.svg" alt="The Lingua Franca Logo" class="lf-navbar-logo themedComponent_mlkZ themedComponent--light_NVdE"><img src="../../img/lf-fordark.svg" alt="The Lingua Franca Logo" class="lf-navbar-logo themedComponent_mlkZ themedComponent--dark_xIcU"></div></a><a class="navbar__item navbar__link" href="../../docs/index.html">Handbook</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="../index.html">Blog</a><a class="navbar__item navbar__link" href="../../research/index.html">Research</a><a class="navbar__item navbar__link" href="../../community/index.html">Community</a><a class="navbar__item navbar__link" href="../../events/index.html">Events</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" href="../../docs/index.html">0.11.0</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="../../docs/next/index.html">Nightly ðŸš§</a></li><li><a class="dropdown__link" href="../../docs/index.html">0.11.0</a></li><li><a class="dropdown__link" href="../../docs/0.10.0">0.10.0</a></li><li><a class="dropdown__link" href="../../docs/0.9.0">0.9.0</a></li><li><a class="dropdown__link" href="../../docs/0.8.0">0.8.0</a></li><li><a class="dropdown__link" href="../../docs/0.7.0">0.7.0</a></li><li><a class="dropdown__link" href="../../docs/0.6.0">0.6.0</a></li><li><a class="dropdown__link" href="../../docs/0.5.0">0.5.0</a></li></ul></div><a href="https://github.com/lf-lang/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="../decentralized-consistency/index.html">Decentralized Consistency</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="index.html">Working with Deadlines</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2023</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="../lingo/index.html">The Lingo Package Manager</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="../docusaurus/index.html">New Lingua Franca Website</a></li></ul></div></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">Working with Deadlines</h1><div class="container_mt6G margin-vert--md"><time datetime="2025-08-23T00:00:00.000Z">August 23, 2025</time> Â· <!-- -->15 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="http://people.eecs.berkeley.edu/~eal/" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://avatars.githubusercontent.com/u/8513334?v=4" alt="Edward A. Lee"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="http://people.eecs.berkeley.edu/~eal/" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Edward A. Lee</span></a></div><small class="authorTitle_nd0D" title="Professor at UC Berkeley">Professor at UC Berkeley</small><div class="authorSocials_rSDt"></div></div></div></div><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://www.linkedin.com/in/ravicakella/" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://avatars.githubusercontent.com/u/913550?v=4" alt="Ravi Akella"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://www.linkedin.com/in/ravicakella/" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Ravi Akella</span></a></div><small class="authorTitle_nd0D" title="Sr. Research Engineer, DENSO International America Inc.">Sr. Research Engineer, DENSO International America Inc.</small><div class="authorSocials_rSDt"></div></div></div></div><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://dblp.org/pid/347/8232.html" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://avatars.githubusercontent.com/u/47446988?v=4" alt="Francesco Paladino"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://dblp.org/pid/347/8232.html" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Francesco Paladino</span></a></div><small class="authorTitle_nd0D" title="Postdoc, UC Berkeley">Postdoc, UC Berkeley</small><div class="authorSocials_rSDt"></div></div></div></div><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/keiichibando" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://avatars.githubusercontent.com/u/149469685?v=4" alt="Keiichi Bando"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/keiichibando" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Keiichi Bando</span></a></div><small class="authorTitle_nd0D" title="Chief Engineer, DENSO Create Inc.">Chief Engineer, DENSO Create Inc.</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p><img decoding="async" loading="lazy" alt="SensorProcessorActuator diagram" src="../../assets/images/SensorProcessorActuator-afa90dcb5edb4cdb7f404e307b3a9ef3.svg" width="363" height="114" class="img_ev3q"></p>
<p><a href="../../docs/writing-reactors/deadlines/index.html">Deadlines</a> in Lingua Franca serve three purposes: they specify real-time requirements, guide scheduling, and provide fault handlers to invoke when real-time requirements are not met.
But they can be subtle to use, and, do not guide scheduling as much as we would like.
This blog outlines the current state of affairs and lays out ongoing work to improve the situation.</p>
<p>A deadline specifies that the physical time at which a reaction <em>starts</em> minus the logical time of that reaction (a time difference called the <strong>lag</strong>) should not exceed some threshold. If it does, then the <strong>deadline violation handler</strong> is invoked rather than the regular reaction.</p>
<p>Deadlines expose a number of scheduling subtleties because unrelated reactions can cause a deadline violation.
Moreover, many users wonder why the deadline refers to the physical time at which a reaction <em>starts</em> rather than the time at which it <em>ends</em>.
Here, we explain some of the subtleties.</p>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="typical-deadline-pattern">Typical Deadline Pattern<a href="#typical-deadline-pattern" class="hash-link" aria-label="Direct link to Typical Deadline Pattern" title="Direct link to Typical Deadline Pattern">â€‹</a></h2>
<p>The diagram above depicts a typical pattern, where a periodic reaction polls sensor data, a <code>Processor</code> reactor processes the data, and an <code>Actuator</code> reactor produces some response.
An <strong>end-to-end</strong> deadline is specified as follows (illustrated in the C target):</p>
<pre class="shiki"><code>reactor Actuator(limit: time = 50 ms) {
  input inp:int
  reaction(inp) {=
    // Regular reaction.
    lf_print(&quot;Met deadline. Received %d.&quot;,  inp-&gt;value);
  =} deadline (limit) {=
    // Deadline violation handler.
    lf_print(&quot;******* Missed deadline! Received %d.&quot;, inp-&gt;value);
  =}
}
</code></pre>
<p>The deadline shows up in the diagram with a stopwatch symbol.</p>
<p>In this example, because of the timer in the <code>Sensor</code> reactor, the logical times of the events, relative to the start time, are 0, 200 ms, 400 ms, etc., for all reactions.
If the <code>Actuator</code> reaction is invoked at a relative physical time greater than 50 ms, 250 ms, 450 ms, etc., then the deadline violation handler will be invoked rather than the regular reaction.
It will print &quot;******* Missed deadline!&quot; rather than &quot;Met deadline.&quot;</p>
<p>This deadline is an <strong>end-to-end</strong> deadline because it accounts for any overhead in invoking the sensor, processing its data, communicating between reactors, and scheduling reactions.
It does not account for any processing done in the <code>Actuator</code> reaction; the intent is that this be a quick driver, not doing a significant amount of processing.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="why-does-a-deadline-constrain-the-start-time-of-a-reaction-rather-than-the-end-time">Why does a deadline constrain the start time of a reaction rather than the end time?<a href="#why-does-a-deadline-constrain-the-start-time-of-a-reaction-rather-than-the-end-time" class="hash-link" aria-label="Direct link to Why does a deadline constrain the start time of a reaction rather than the end time?" title="Direct link to Why does a deadline constrain the start time of a reaction rather than the end time?">â€‹</a></h3>
<p>In a typical usage, it may not make sense to actuate based on late data, so we don&#x27;t want to execute the regular reaction only to then discover that the deadline was violated.
Hence, in this usage, specifying a deadline on the completion of the <code>Actuator</code> reaction would not make sense.</p>
<p>Specifying a deadline on the completion the <code>Processor</code> reaction would also not make sense.
Usually, nobody cares when processing completes; we only care when the results have an effect in the real world.
If we specified only a completion-time deadline for the <code>Processor</code> reaction, then nothing would constrain when the <code>Actuator</code> reaction is invoked.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="specifying-a-deadline-on-completion-time">Specifying a Deadline on Completion Time<a href="#specifying-a-deadline-on-completion-time" class="hash-link" aria-label="Direct link to Specifying a Deadline on Completion Time" title="Direct link to Specifying a Deadline on Completion Time">â€‹</a></h2>
<p>Although the above pattern is typical, it is not uncommon to actually want to specify a deadline on a completion time.
Fortunately, this can be easily done with the pattern shown below:</p>
<p><img decoding="async" loading="lazy" alt="CheckDeadline diagram" src="../../assets/images/CheckDeadline-f97a3e52d0db8162349f735596399cb9.svg" width="278" height="162" class="img_ev3q"></p>
<p>The <code>Check</code> reactor may be specified as follows:</p>
<pre class="shiki"><code>reactor Check(exec = 10 ms, limit: time = 50 ms) {
  input inp:int
  reaction(inp) {=
    lf_sleep(self-&gt;exec);
    lf_print(&quot;Received %d.&quot;, inp-&gt;value);
  =}
  reaction(inp) {=
    lf_print(&quot;Met deadline.&quot;);
  =} deadline (limit) {=
    lf_print(&quot;******* Missed deadline!&quot;);
  =}
}
</code></pre>
<p>This reactor has an <code>exec</code> parameter that specifies an (approximate) execution time, in this test case realized using <code>lf_sleep</code>.
It has a second reaction triggered by the same input that has a deadline given by the <code>limit</code> parameter.
If <code>limit</code> is enough larger than <code>exec</code>, then the deadline will be met.
Otherwise, it will be violated.</p>
<p>This pattern works because reactions belonging to the same reactor are not allowed to execute concurrently (because this would create race conditions accessing state variables). They must execute in sequence, in the order in which they are defined. The numbering in the diagram indicates this ordering.</p>
<p>When an input arrives, both reactions will be triggered.
But because the reactions must execute in the sequence that they are defined, a constraint on the start time of the second reaction is effectively a deadline on the completion time of the first reaction.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="what-keeps-other-reactions-from-executing-between-the-invocation-of-the-first-reaction-and-the-invocation-of-the-second">What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?<a href="#what-keeps-other-reactions-from-executing-between-the-invocation-of-the-first-reaction-and-the-invocation-of-the-second" class="hash-link" aria-label="Direct link to What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?" title="Direct link to What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?">â€‹</a></h3>
<p>Ideally, the LF scheduler would be using an <strong>earliest deadline first</strong> (<strong>EDF</strong>) scheduling policy.
Under an EDF scheduling policy, upon completion of the first reaction, the second reaction will have a priority based on the time remaining until its deadline is violated.
Under EDF, only another reaction that is <em>also</em> at risk of violating its deadline could execute between these two.
However, LF does not (yet) implement EDF.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="scheduling">Scheduling<a href="#scheduling" class="hash-link" aria-label="Direct link to Scheduling" title="Direct link to Scheduling">â€‹</a></h2>
<p>As of version 0.10.1, the default schedulers in all targets of LF have significant limitations dealing with deadlines and do not implement EDF scheduling.
Here, we explain how scheduling works in version 0.10.1 and then outline research efforts towards achieving EDF scheduling.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="level-scheduling">Level scheduling<a href="#level-scheduling" class="hash-link" aria-label="Direct link to Level scheduling" title="Direct link to Level scheduling">â€‹</a></h3>
<p>The schedulers all use a <strong>level scheduling</strong> heuristic to ensure that all precedences have been satisfied when a reaction is invoked.
At each tag (logical time and microstep), several reactions may be triggered.
If there are no dependencies between these reactions, and if there is more than one worker thread, then reactions may be invoked in parallel.
But the scheduler has to ensure that precedences are satisfied.</p>
<p>A reaction <code>r1</code> has precedence over a reaction <code>r2</code> if there is a path (without <code>after</code> delays) from outputs that <code>r1</code> writes to to inputs that <code>r2</code> uses.
In addition, if <code>r1</code> and <code>r2</code> belong to the same reactor, and <code>r1</code> is defined before <code>r2</code>, then <code>r1</code> has precedence.
If <code>r1</code> has precedence over <code>r2</code>, then <code>r1</code> must complete before <code>r2</code> can start.</p>
<p>For efficiency, the default schedulers use a conservative approach called &quot;level scheduling.&quot;
At compile time, the dependencies between reactions are analyzed, and an acyclic precedence graph (APG) is constructed.
The <strong>level</strong> of a reaction <code>r</code> is defined as the length of the largest upstream chain of reactions that have precedence over <code>r</code>.
If no reaction has precedence over <code>r</code>, its level is zero.
If exactly one reaction has precedence over <code>r</code>, and that reaction does not depend on other reactions, then <code>r</code> has level one. Etc.</p>
<p>The default schedulers all require that all reactions with level <em>n</em> complete before any reaction with level <em>n</em> + 1 can begin.
This constraint can cause unexpected deadline violations.</p>
<p>Consider program with the following structure:</p>
<p><img decoding="async" loading="lazy" alt="ParallelSensorProcessorActuator diagram" src="../../assets/images/ParallelSensorProcessorActuator-eaedffcd19a6df0845a907726e0d015f.svg" width="380" height="212" class="img_ev3q"></p>
<p>Suppose that <code>p1</code> has an execution time of 60 ms and <code>p2</code> has an execution time of 10 ms.
Then we might expect the deadline at <code>a1</code> to be violated and the deadline at <code>a2</code> to be met.
But this is not what happens.
The reactions in <code>a1</code> and <code>a2</code> both have level 2.
Because of the level scheduling, the reactions in <em>both</em> <code>p1</code> and <code>p2</code>, which have level 1, must complete before either actuator can be invoked.
Hence, both deadlines are violated.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="federated-execution">Federated Execution<a href="#federated-execution" class="hash-link" aria-label="Direct link to Federated Execution" title="Direct link to Federated Execution">â€‹</a></h3>
<p>One way to get around the level-scheduling limitation is to make the program federated, splitting it into separate processes, each of which will have its own scheduler, as shown here:</p>
<p><img decoding="async" loading="lazy" alt="FederatedSensorProcessorActuator diagram" src="../../assets/images/FederatedSensorProcessorActuator-5b123baf8fe678870d685ce3b4c9bcd5.svg" width="404" height="326" class="img_ev3q"></p>
<p>Here, <code>pa1</code> will consistently miss deadlines (because of the <code>exec</code> parameter value of 60 ms), whereas <code>pa2</code> will consistently meet the deadline. This structure is defined by the following code:</p>
<pre class="shiki"><code>import Sensor, Processor, Actuator from &quot;SensorProcessorActuator.lf&quot;

reactor ProcessorActuator(exec = 10 ms, limit = 50 ms) {
  input sensor: int
  p = new Processor(exec = exec)
  a = new Actuator(limit = limit)
  sensor -&gt; p.inp
  p.out -&gt; a.inp
}

federated reactor {
  s = new Sensor()
  pa1 = new ProcessorActuator(exec = 60 ms)
  pa2 = new ProcessorActuator()
  s.out -&gt; pa1.sensor
  s.out -&gt; pa2.sensor
}
</code></pre>
<p>This can be also be made with two federates rather than three, as shown here:</p>
<p><img decoding="async" loading="lazy" alt="FederatedSmaller diagram" src="../../assets/images/FederatedSmaller-ee9cda00b2d5ad9dbe7e358e7d0d031e.svg" width="657" height="238" class="img_ev3q"></p>
<p>Some care is needed in this case because the code generator inserts a <code>NetworkSender</code> reactor, as shown below:</p>
<p><img decoding="async" loading="lazy" alt="federate__spa diagram" src="../../assets/images/federate__spa-b0673045f993c172bcca6356067f4479.svg" width="650" height="224" class="img_ev3q"></p>
<p>This is a code-generated Lingua Franca file for the <code>spa</code> federate alone.
In this case, the reaction in the <code>NetworkSender</code> will have the same level as the reaction in the <code>Processor</code> and hence may get delayed, causing the deadline to be missed at the <code>pa</code> federate.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="early-deadline-violation-detection">Early Deadline Violation Detection<a href="#early-deadline-violation-detection" class="hash-link" aria-label="Direct link to Early Deadline Violation Detection" title="Direct link to Early Deadline Violation Detection">â€‹</a></h2>
<p>A deadline violation handler is invoked when a reaction is to be <em>started</em> late.
Above, we explained how to react to a late <em>completion time</em> of a reaction, but the handler is not invoked until the reaction actually completes.
What if you need to react as soon as you know that the completion time will be late?
Here we describe three complementary mechanisms that can react sooner.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="reactions-that-monitor-their-execution-time">Reactions that Monitor Their Execution Time<a href="#reactions-that-monitor-their-execution-time" class="hash-link" aria-label="Direct link to Reactions that Monitor Their Execution Time" title="Direct link to Reactions that Monitor Their Execution Time">â€‹</a></h3>
<p>The <a href="https://www.lf-lang.org/reactor-c/group__API.html#gab3a04dd0a1581844829b28686b6b3c53" target="_blank" rel="noopener noreferrer"><code>lf_check_deadline</code></a> function in the <a href="https://www.lf-lang.org/reactor-c/group__API.html" target="_blank" rel="noopener noreferrer">reactor API</a> can be used to write a reaction that monitors its own execution time against a deadline and invokes its deadline violation handler as soon as it detects that the execution time has exceeded the deadline.
This mechanism works when the reaction is <em>started</em> on time, but when we want it to terminate its execution when it cannot <em>complete</em> on time.
A nice example of this is given in the <a href="https://github.com/lf-lang/playground-lingua-franca/blob/main/examples/C/src/deadlines/AnytimePrime.lf" target="_blank" rel="noopener noreferrer">AnytimePrime.lf</a> example in the <a href="https://github.com/lf-lang/playground-lingua-franca/blob/main/examples/C/src/deadlines/README.md" target="_blank" rel="noopener noreferrer">deadline collection</a> of the <a href="https://github.com/lf-lang/playground-lingua-franca/tree/main" target="_blank" rel="noopener noreferrer">LF playground repo</a>.
It computes as many prime numbers as it can before exceeding a time budget and then aborts.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="federates-as-watchdog-like-monitors">Federates as Watchdog-Like Monitors<a href="#federates-as-watchdog-like-monitors" class="hash-link" aria-label="Direct link to Federates as Watchdog-Like Monitors" title="Direct link to Federates as Watchdog-Like Monitors">â€‹</a></h3>
<p>The <a href="https://www.lf-lang.org/docs/next/writing-reactors/distributed-execution#decentralized-coordination" target="_blank" rel="noopener noreferrer">decentralized coordinator</a> for federated execution gives a convenient mechanism for creating a form of watchdog-like monitor that runs in a separate process or even on a separate machine.
This can give a robust detection of a failure because the monitor can be put on a separate machine from the process being monitored.</p>
<p>Consider the following example:</p>
<p><img decoding="async" loading="lazy" alt="FederatedWatchdog diagram" src="../../assets/images/FederatedWatchdog-eb5871ee989a43e2c5b0d87592a82f18.svg" width="534" height="202" class="img_ev3q"></p>
<pre class="shiki"><code>target C {
  coordination: decentralized
}
import Sensor, Processor, Actuator from &quot;SensorProcessorActuator.lf&quot;

reactor Monitored(exec = 10 ms) {
  output complete:int
  s = new Sensor()
  p = new Processor(exec = exec)
  a = new Actuator()
  s.out -&gt; p.inp
  p.out -&gt; a.inp
  p.out -&gt; complete
}

reactor Monitor(STA: time = 50 ms) {
  input inp:int
  timer t(0, 200 ms)

  reaction(t, inp) {=
    if (!inp-&gt;is_present) {
      lf_print(&quot;%s: ******* Failed to receive input on time at logical time &quot; PRINTF_TIME,
          lf_reactor_name(self), lf_time_logical_elapsed());
    } else {
      lf_print(&quot;%s: Monitor OK at logical time &quot; PRINTF_TIME,
          lf_reactor_name(self), lf_time_logical_elapsed());
    }
  =} STAA(0) {=
    lf_print(&quot;%s: ******* Monitor received late input.&quot;, lf_reactor_name(self));
  =}
}

federated reactor {
  @label(&quot;exec = 60 ms&quot;)
  m = new Monitored(exec = 60 ms)
  @label(&quot;STA = 50 ms&quot;)
  w = new Monitor()
  m.complete -&gt; w.inp
}
</code></pre>
<p>The <code>Monitored</code> reactor is simply a federate containing the sensor-processor-actuator chain.
It is just like above except that it also copies the output of the processor to its own <code>complete</code> output.</p>
<p>The <code>Monitor</code> federate has a timer that exactly matches the <code>Sensor</code> timer in offset and period.
The <code>Monitor</code> expects an input from <code>Monitored</code> at each tick of this timer.
The <a href="https://www.lf-lang.org/docs/next/writing-reactors/distributed-execution#safe-to-advance-sta" target="_blank" rel="noopener noreferrer"><code>STA</code> parameter</a> (<strong>safe to advance</strong>) specifies that it is safe to advance the federate&#x27;s logical time to the logical time of the timer tick when physical time exceeds that logical time plus the <code>STA</code> even if input status is unknown.
The <code>STA</code> is set to 50 ms, so, at physical times 50 ms, 250 ms, 450 ms, etc. after the start time, if an input has not arrived, then the input will be assumed to be absent and the <code>Monitor</code>&#x27;s reaction will be invoked.
The reaction, therefore, just has to check whether the input is present.
If it is, then the <code>Monitored</code> federate is alive and well and its processor output was received by the <code>Monitor</code> within 50 ms.
Otherwise, something has gone wrong that has led to a delay greater than 50 ms.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="watchdogs">Watchdogs<a href="#watchdogs" class="hash-link" aria-label="Direct link to Watchdogs" title="Direct link to Watchdogs">â€‹</a></h3>
<p>An experimental <code>watchdog</code> mechanism is available in LF and is described by
<a href="https://ieeexplore.ieee.org/document/10693560" target="_blank" rel="noopener noreferrer">Asch, et al., Software-Defined Watchdog Timers for Cyber-Physical Systems</a>.
A <code>watchdog</code> specifies a handler that is invoked if, after the watchdog is started using the <a href="https://www.lf-lang.org/reactor-c/group__API.html#ga82bf2c7bd91fdf03b357914cf875dbb9" target="_blank" rel="noopener noreferrer"><code>lf_watchdog_start</code></a> function in the <a href="https://www.lf-lang.org/reactor-c/group__API.html" target="_blank" rel="noopener noreferrer">reactor API</a>, the watchdog is not stopped or restarted within the specified amount of physical time.</p>
<p>A typical usage is to start a watchdog before a potentially problematic reaction is invoked and then stop the watchdog upon completion of the reaction.
As soon as the reaction takes too long to complete, the watchdog handler will be invoked.</p>
<p>Using watchdogs is tricky because the watchdog handler requires a mutual exclusion lock in order to safely access state variables (see <a href="https://ieeexplore.ieee.org/document/10693560" target="_blank" rel="noopener noreferrer">Asch, et al.</a>.
For this reason, federates (or, in the future, enclaves) are preferred.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="ongoing-research">Ongoing Research<a href="#ongoing-research" class="hash-link" aria-label="Direct link to Ongoing Research" title="Direct link to Ongoing Research">â€‹</a></h2>
<p>Several significant efforts are under way to improve the real-time behavior of LF and to guide scheduling using deadlines.
Some early work is reported in <a href="https://ieeexplore.ieee.org/document/10697337" target="_blank" rel="noopener noreferrer">Paladino, et al., Layered Scheduling: Toward Better Real-Time Lingua Franca</a>.
That work makes use of an early version of the enclaves mechanism, described below.
It leverages priority-based thread scheduling in the standard Linux kernel.
Here, we focus on what is currently available (as of version 0.10.1 and 0.10.2-SNAPSHOT) in LF.</p>
<p>The overarching goal is that reactions with deadlines that are closest to expiring should be given priority and executed as soon as all their precedences have been satisfied.
I.e., ideally, LF would implement EDF.
But it does not. Yet.
Here, we describe some steps towards achieving such a scheduling policy with LF.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="gedf_np-scheduler">GEDF_NP Scheduler<a href="#gedf_np-scheduler" class="hash-link" aria-label="Direct link to GEDF_NP Scheduler" title="Direct link to GEDF_NP Scheduler">â€‹</a></h3>
<p>An early experiment is a scheduler called <code>GEDF_NP</code>, which has some initial efforts towards achieving EDF scheduling, although it has many limitations.
This scheduler is specified using a target property as follows:</p>
<pre class="shiki"><code>target C {
  timeout: 1 s,
  scheduler: GEDF_NP
}
</code></pre>
<p>Unlike the default scheduler, this one takes deadlines into account when sorting events on the event queue.
Consider the following example:</p>
<p><img decoding="async" loading="lazy" alt="MoreParallelSensorProcessorActuator diagram" src="../../assets/images/MoreParallelSensorProcessorActuator-3e799e626be9c646de921253f2d98007.svg" width="379" height="234" class="img_ev3q"></p>
<p>For the purposes of sorting events on the event queue, the <code>GEDF_NP</code> scheduler propagates deadlines upstream from reactions where they are declared.
In this example, the processors and sensors inherit the deadlines of the actuators that they drive.
Hence, sensor <code>s2</code> will be treated as if it has a deadline of 40 ms, while <code>s1</code> will be treated as if it has a deadline of 50 ms.</p>
<p>The timers in each of these sensors have identical periods and offsets, so their events would normally not have any particular ordering.
The <code>GEDF_NP</code> scheduler, however, for events with identical tags, gives priority to those with earlier deadlines.
In the above example, it will pull the timer event for <code>s2</code> from the event queue and process all reactions that this triggers before pulling the timer event for <code>s1</code>.
As a consequence, it overcomes the level-scheduling limitation, and <code>a2</code> will meet its deadline.</p>
<p>There are several downsides to this approach, however.</p>
<p>First, it sacrifices parallelism.
In the above example, suppose that both Processor reactors have an execution time of 30 ms.
In a dual-core (or more) processor, it should be possible to meet both deadlines.
However, the <code>GEDF_NP</code> scheduler processes all the reactions triggered by the timer in <code>s2</code> before even fetching the timer event for <code>s1</code>.
As a consequence, it will miss the deadline in <code>a1</code>.
If the deadlines are made identical, however, both 50 ms, then both deadlines will be met if there are two cores.</p>
<p>Second, the <code>GEDF_NP</code> scheduler only considers (inherited) deadlines when sorting the event queue.
Events that do not pass through the event queue are unaffected.
As a consequence, in the following example, both deadlines are missed, even if the deadlines are identical:</p>
<p><img decoding="async" loading="lazy" alt="ParallelSensorProcessorActuator diagram" src="../../assets/images/ParallelSensorProcessorActuator2-c31c8e04487dbef16756335f10d45073.svg" width="380" height="212" class="img_ev3q"></p>
<p>At each tag, there is only one event, the one for the timer in the <code>s</code> sensor.
The reaction in <code>s</code> will have an inherited deadline of 40 ms (the smaller of the two downstream deadlines), but there is no other competing event with the same tag, so the <code>GEDF_NP</code> scheduler will have no effect.</p>
<p>Third, the <code>GEDF_NP</code> scheduler underperforms the default scheduler by a considerable margin.
It is slower.</p>
<p>As a consequence of these limitations, the <code>GEDF_NP</code> scheduler is likely to be retired.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="enclaves">Enclaves<a href="#enclaves" class="hash-link" aria-label="Direct link to Enclaves" title="Direct link to Enclaves">â€‹</a></h3>
<p>As of version 0.10.2-SNAPSHOT, the development version after the 0.10.1 release, there is some support for <strong>scheduling enclaves</strong>.
These are similar to federates, in that they create separated scheduling domains, but they execute within the same process as their container.
Such an enclave can be created using an <code>@enclave</code> annotation, as shown here:</p>
<pre class="shiki"><code>main reactor {
  ...
  @enclave
  pa = new ProcessorActuator(exec = 60 ms)
  ...
}
</code></pre>
<p>The resulting diagram shows a red outline for the enclave:</p>
<p><img decoding="async" loading="lazy" alt="EnclavedProcessorActuator diagram" src="../../assets/images/EnclavedProcessorActuator-a2d784a5bc35ae442795b17fd0c468ad.svg" width="489" height="247" class="img_ev3q"></p>
<p>In this case, as with the federate execution, the deadline will be systematically met at actuator <code>a1</code> but missed at actuator <code>pa.a</code>.</p>
<p>As with federated execution, there is a subtlety because an <code>EnclaveCommunication</code> reactor is inserted on the communication path to the enclave.
It has two reactions separated by a logical action, so, for this particular structure, the reaction that sends data to <code>pa</code> will have the same level as the reaction in <code>p1</code>.</p>
<p>Enclaves realize the equivalent of centralized coordination, which makes sense because they all run in the same process.
However, this means that the <code>FederatedWatchdog</code> example cannot be converted as-is to use enclaves.
A similar monitor, however, can be created using a physical connection.</p>
<p>The goal of enclaves is to achieve the same decoupling as with federates, but with all enclaves executing in the same process and communicating via shared memory.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusions">Conclusions<a href="#conclusions" class="hash-link" aria-label="Direct link to Conclusions" title="Direct link to Conclusions">â€‹</a></h2>
<p>Today, the deadline mechanism in LF provides a useful mechanism for detecting and reacting to timing anomalies.
But LF does not yet have an effective scheduler that prioritizes reactions with earlier deadlines.</p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="../tags/lingua-franca/index.html">lingua franca</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="../tags/deadlines/index.html">deadlines</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="../tags/real-time/index.html">real-time</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="../tags/scheduling/index.html">scheduling</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="../decentralized-consistency/index.html"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">Decentralized Consistency</div></a><a class="pagination-nav__link pagination-nav__link--next" href="../lingo/index.html"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">The Lingo Package Manager</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#typical-deadline-pattern" class="table-of-contents__link toc-highlight">Typical Deadline Pattern</a><ul><li><a href="#why-does-a-deadline-constrain-the-start-time-of-a-reaction-rather-than-the-end-time" class="table-of-contents__link toc-highlight">Why does a deadline constrain the start time of a reaction rather than the end time?</a></li></ul></li><li><a href="#specifying-a-deadline-on-completion-time" class="table-of-contents__link toc-highlight">Specifying a Deadline on Completion Time</a><ul><li><a href="#what-keeps-other-reactions-from-executing-between-the-invocation-of-the-first-reaction-and-the-invocation-of-the-second" class="table-of-contents__link toc-highlight">What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?</a></li></ul></li><li><a href="#scheduling" class="table-of-contents__link toc-highlight">Scheduling</a><ul><li><a href="#level-scheduling" class="table-of-contents__link toc-highlight">Level scheduling</a></li><li><a href="#federated-execution" class="table-of-contents__link toc-highlight">Federated Execution</a></li></ul></li><li><a href="#early-deadline-violation-detection" class="table-of-contents__link toc-highlight">Early Deadline Violation Detection</a><ul><li><a href="#reactions-that-monitor-their-execution-time" class="table-of-contents__link toc-highlight">Reactions that Monitor Their Execution Time</a></li><li><a href="#federates-as-watchdog-like-monitors" class="table-of-contents__link toc-highlight">Federates as Watchdog-Like Monitors</a></li><li><a href="#watchdogs" class="table-of-contents__link toc-highlight">Watchdogs</a></li></ul></li><li><a href="#ongoing-research" class="table-of-contents__link toc-highlight">Ongoing Research</a><ul><li><a href="#gedf_np-scheduler" class="table-of-contents__link toc-highlight">GEDF_NP Scheduler</a></li><li><a href="#enclaves" class="table-of-contents__link toc-highlight">Enclaves</a></li></ul></li><li><a href="#conclusions" class="table-of-contents__link toc-highlight">Conclusions</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://zulip.lf-lang.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">Zulip<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="../index.html">Blog</a></li><li class="footer__item"><a href="https://github.com/lf-lang" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2026 The Lingua Franca project. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>