<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.lf-lang.org/blog/</id>
    <title>Lingua Franca Blog</title>
    <updated>2025-10-14T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.lf-lang.org/blog/"/>
    <subtitle>Lingua Franca Blog</subtitle>
    <icon>https://www.lf-lang.org/img/favicon.png</icon>
    <entry>
        <title type="html"><![CDATA[Decentralized Consistency]]></title>
        <id>https://www.lf-lang.org/blog/decentralized-consistency/</id>
        <link href="https://www.lf-lang.org/blog/decentralized-consistency/"/>
        <updated>2025-10-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The design of distributed applications in Lingua Franca requires care, particularly if the coordination of the federation is decentralized. The intent of this post is to illustrate and handle the challenges arising from designing distributed applications in Lingua Franca, with the help of two realistic use cases.]]></summary>
        <content type="html"><![CDATA[<p>The design of <a href="https://www.lf-lang.org/docs/writing-reactors/distributed-execution/">distributed applications</a> in Lingua Franca requires care, particularly if the coordination of the federation is <a href="https://www.lf-lang.org/docs/writing-reactors/distributed-execution/#decentralized-coordination">decentralized</a>. The intent of this post is to illustrate and handle the challenges arising from designing distributed applications in Lingua Franca, with the help of two realistic use cases.</p>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="indefinite-wait-for-inputs-aircraft-door-use-case">Indefinite wait for inputs: aircraft door use case<a href="https://www.lf-lang.org/blog/decentralized-consistency/#indefinite-wait-for-inputs-aircraft-door-use-case" class="hash-link" aria-label="Direct link to Indefinite wait for inputs: aircraft door use case" title="Direct link to Indefinite wait for inputs: aircraft door use case">​</a></h2>
<p>Aircraft doors on passenger flights are currently managed manually by flight attendants.
Before takeoff, the flight attendants <em>arm</em> the door; if the door is opened in this state, an evacuation slide is automatically inflated and deployed for emergency evacuation.
When the aircraft is at a gate, before opening the door, the flight attendants <em>disarm</em> it to avoid the deployment of the evacuation slide.
Flight attendants are allowed to disarm the door <em>only</em> when they see through the porthole the ramp that will allow the passengers to disembark the aircraft.</p>
<p><img decoding="async" loading="lazy" alt="AircraftDoor diagram" src="https://www.lf-lang.org/assets/images/AircraftDoor-db4cdc2f3abf2013b63db4d1c7201e83.svg" width="559" height="128" class="img_ev3q"></p>
<p>Consider the above Lingua Franca program that implements a simplified system to remotely open an aircraft door that is in the <em>armed</em> state.
The door implements two independent remote services, door <em>disarming</em> and door <em>opening</em>, encoded by two different reactions in the <code>Door</code> reactor.
Suppose the pilot in the cockpit issues a command to open the door.
We would also like to automate the disarming of the door using a camera to verify the presence of a ramp. When the camera determines that the ramp is present, it triggers the disarming service. The camera detection is triggered by the door open command issued from the cockpit.</p>
<p>There are different ways to design and refactor the above system, for example, by removing the direct connection between the <code>Cockpit</code> and <code>Door</code> reactors. Our design choice is meant to highlight that door <em>disarming</em> and <em>opening</em> are two different and independent remote services triggered by two different commands issued by two different system actors. Therefore, each actor has an independent connection to the door to request its service.</p>
<p>The purpose of the system is to open the door in reaction to the command from the cockpit whether or not a ramp is present. If a ramp is present, it is imperative that the door be disarmed <em>before</em> being opened. Hence, the door, upon receiving the <code>open</code> command from the cockpit, should wait for input from the camera before opening.</p>
<p>The order in which messages are processed is crucial in this application. When the <em>disarm</em> and <em>open</em> commands arrive with the same tag, the <em>disarm</em> service needs to be invoked before opening the door, otherwise the escape slide will be erroneously deployed.
Lingua Franca guarantees determinism in the execution order of reactions with logically simultaneous inputs, and the order is given by the the order of declaration of the reactions inside the reactor. It is then sufficient to declare the <code>disarm</code> reaction <em>before</em> the <code>open</code> one. The diagram confirms the execution order by labeling the <code>disarm</code> reaction with 1 and the <code>open</code> reaction with 2.</p>
<p>The problem is that even though the messages are <em>logically</em> simultaneous, they do not arrive at the same <em>physical</em> time. In fact, the <code>open</code> command from the cockpit is likely to arrive before the clearance from the camera because the camera realizes an expensive computer vision algorithm. The door, consequently, has to wait for both inputs before invoking the <em>opening</em> service.</p>
<p>This is an example of an application that cannot safely proceed without assurance on its inputs. The following section explains how to obtain the desired behavior in Lingua Franca using the decentralized coordinator (the centralized coordinator automatically provides the required assurance).</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="consistency-with-decentralized-coordination">Consistency with decentralized coordination<a href="https://www.lf-lang.org/blog/decentralized-consistency/#consistency-with-decentralized-coordination" class="hash-link" aria-label="Direct link to Consistency with decentralized coordination" title="Direct link to Consistency with decentralized coordination">​</a></h3>
<p>The application is implemented as a federated program with decentralized coordination, which means that the advancement of logical time in each single federate is not subject to approval from any centralized entities, but it is done locally based on the input it receives from the other federates and on its local physical clock.</p>
<p>Let us consider the case when the <code>Door</code> reactor receives the <em>open</em> command from the <code>Cockpit</code> reactor, but not yet the <em>disarm</em> command from the <code>Camera</code> reactor. As previously observed, the <code>Door</code> cannot proceed to invoke the <em>opening</em> service, because it needs to wait for the <code>Camera</code> to send the <em>disarm</em> command.
But how long should it wait?</p>
<p>The decentralized coordinator in
Lingua Franca allows you to customize this waiting time. Each federate can be assigned an attribute called <a href="https://www.lf-lang.org/docs/writing-reactors/distributed-execution/#safe-to-advance-sta"><code>maxwait</code></a> that controls how long the federate should wait for inputs from other federates before processing an event, such as an input it has just received.
More precisely, <code>maxwait</code> is the maximum amount of time a federate waits before advancing its logical time to some value <em>t</em>. Specifically, to advance to logical time <em>t</em>, the federate waits until either all inputs are known up to an including time <em>t</em> or its local physical clock exceeds <em>t</em> +<code>maxwait</code>.
An input is known up to an including time <em>t</em> if a message with timestamp <em>t</em> or greater has been received on that input port.
At the expiration of the <code>maxwait</code>, the federate assumes that any unresolved ports will not receive any messages with timestamps <em>t</em> or earlier.
It can then advance its logical time to <em>t</em>.</p>
<p>In our example, we want the door to <em>wait indefinitely</em> for both <em>disarm</em> and <em>open</em> commands to arrive before processing any of them. In Lingua Franca, this is obtained by setting <code>maxwait</code> to <code>forever</code>. The <code>Door</code> reactor cannot safely proceed without assurance about the inputs.</p>
<p>The implementation of the <code>Door</code> reactor and its instantiation are shown below:</p>
<pre class="shiki"><code>reactor Door {
  input open: bool
  input disarm: bool
  state isDisarmed: bool = false
  state isOpen: bool = false

  reaction(disarm) {=
    if (disarm-&gt;value) {
      self-&gt;isDisarmed = true;
      printf("Door disarmed\n");
    } else {
      self-&gt;isDisarmed = false;
      printf("Door armed\n");
    }
  =} tardy {=
    printf("STP violation\n");
    printf("Intended tag: %lld\n", disarm-&gt;intended_tag);
    printf("Current tag: %lld\n", lf_time_logical());
  =}

  reaction(open) {=
    if (open-&gt;value) {
      self-&gt;open = true;
      printf("Door open\n");
    } else {
      self-&gt;open = false;
      printf("Door closed\n");
    }
  =} tardy {=
    printf("STP violation\n");
    printf("Intended tag: %lld\n", disarm-&gt;intended_tag);
    printf("Current tag: %lld\n", lf_time_logical());
  =}
}

federated reactor {
  c = new Cockpit()
  v = new Camera()
  
  @maxwait(forever)
  d = new Door()

  c.open -&gt; d.open
  c.open -&gt; v.check_ramp
  v.ramp_present -&gt; d.disarm
}
</code></pre>
<p>The <code>maxwait</code> attribute is specified at instantiation time within the main reactor. Right before creating the instance of the <code>Door</code> reactor for which we want to set the attribute, we use the <code>@maxwait</code> annotation that takes as input the <code>maxwait</code> value.</p>
<p>The reactions of the <code>Door</code> reactor provide <a href="https://www.lf-lang.org/docs/writing-reactors/distributed-execution/#safe-to-process-stp-violation-handling">fault handlers</a> that are invoked in case the federate assumed inputs were known up to timestamp <em>t</em> and then later received a message with timestamp <em>t</em> or less. When <code>maxwait</code> is <code>forever</code>, these fault handlers should never be invoked.</p>
<p>For finite values of <code>maxwait</code>, it is always possible for messages to get sufficiently delayed that the fault handlers will be invoked.
When they are invoked, the current tag will be greater than the intended tag of the message.
This type of fault is called a <strong>safe-to-process</strong> (<strong>STP</strong>) violation because messages are being handled out of tag order.
The intended tag of the input can be accessed as shown in the code above.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="multirate-inputs-automatic-emergency-braking">Multirate inputs: automatic emergency braking<a href="https://www.lf-lang.org/blog/decentralized-consistency/#multirate-inputs-automatic-emergency-braking" class="hash-link" aria-label="Direct link to Multirate inputs: automatic emergency braking" title="Direct link to Multirate inputs: automatic emergency braking">​</a></h2>
<p><img decoding="async" loading="lazy" alt="AutomaticEmergencyBrakingSystem diagram" src="https://www.lf-lang.org/assets/images/AutomaticEmergencyBrakingSystem-c4e7a155519baf77598fc57b9f4aae04.svg" width="933" height="354" class="img_ev3q"></p>
<p>Consider the above Lingua Franca implementation of an automatic emergency braking system, one of the most critical ADAS systems that modern cars are equipped with.
The controller system modeled by the <code>AutomaticEmergencyBraking</code> reactor reads data coming from two sensors, a lidar and a radar, and uses both to detect objects or pedestrians that cross the trajectory the car.
This is a <em>sensor fusion</em> problem, where a diversity of sensors is used to get better reliability.
When one of the two sensors signals the presence of an object at a distance shorter than a configurable threshold, the controller triggers the brake to stop the car and avoid crashing into it.</p>
<p>The sensors are modeled with their own timer that triggers the generation of data. The clocks of all federates are automatically synchronized by the <a href="https://www.lf-lang.org/docs/writing-reactors/distributed-execution/#clock-synchronization">clock synchronization algorithm</a> of the Lingua Franca runtime (unless this is disabled).
Typically, in a real use case of this kind, the clock of sensor devices cannot be controlled by Lingua Franca, but a way to work around this limitation is to resample the data collected by sensors with the timing given by a clock that the runtime can control.
The sensor reactors of our application are then modeling this resampling of sensor data so that alignment of data from the two sensors is well defined and sensor fusion becomes possible.</p>
<p>The lidar sensor has a sampling frequency that is twice that of the radar, as indicated by the timers in the corresponding reactors; the lidar timer has a period of 50ms, while that of the radar 100ms.
Their deadline is equal to their period and is enforced using the dedicated <code>DeadlineCheck</code> reactors, following the guidelines of how to <a href="https://www.lf-lang.org/blog/deadlines/">work with deadlines</a>.</p>
<p>The sensor behavior in the application can be simulated for testing purposes in a way that each sensor constantly produces distance values above the threshold (i.e., no objects in the way), and then at a random time it sends a distance value below the threshold, indicating the presence of a close object. When the <code>AutomaticEmergencyBraking</code> reactor receives that message, it signals the <code>BrakingSystem</code> reactor to brake the car, and the whole system shuts down.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="desired-system-properties">Desired system properties<a href="https://www.lf-lang.org/blog/decentralized-consistency/#desired-system-properties" class="hash-link" aria-label="Direct link to Desired system properties" title="Direct link to Desired system properties">​</a></h3>
<p>Availability is a crucial property of this application, because we want the automatic emergency braking system to brake as fast as possible when a close object is detected. Consistency is also necessary, as sensor fusion happens with sensor data produced at the same logical time. Even if this is not implemented in our simplified example, sensor fusion in a more general scenario helps rule out false positives, i.e., cases in which one of the sensors erroneously detects a close object that would induce an unnecessary and dangerous braking. False positives are caused by the weaknesses of the specific sensor. For example, rainy or foggy weather reduces the accuracy of lidar sensors. The key concept is to gather data produced at the same logical time by all sensors and combine them to have a more accurate estimate of possible collisions. Consistency and in-order data processing are then required.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="consistency-challenge">Consistency challenge<a href="https://www.lf-lang.org/blog/decentralized-consistency/#consistency-challenge" class="hash-link" aria-label="Direct link to Consistency challenge" title="Direct link to Consistency challenge">​</a></h4>
<p>The application is once agin implemented as a federated program with decentralized coordination.
Consistency problems may arise when a federate receives data from two or more federates, as it is the case of the <code>AutomaticEmergencyBraking</code> reactor.
The controller expects to receive input from both sensors at times 0ms, 100ms, 200ms, etc. Let's consider as an example the case where the remote connection between the controller and the radar has a slightly larger delay than that between the controller and the lidar. The lidar input will then always arrive slightly earlier than the radar one. When the controller receives the lidar input, should it process the data immediately, or should it wait for the radar input to come? Sensor fusion requires consistency: if the controller processes the input from the lidar and then the radar data comes, the control action elaborated upon the arrival of the lidar data does not take into account both sensors, even though it should. Hence, in our use case, the <code>AutomaticEmergencyBraking</code> reactor needs to wait for both inputs before processing new data.</p>
<p>In our application, if we aim to process all incoming data with the same logical time to realize sensor fusion, then we can set <code>maxwait = forever</code> to <em>wait indefinitely</em> for the radar input before processing the radar.
Note that this might not be a good choice in this example because if a fault causes one of the sensors to stop sending messages, the ADAS system will stop working.
Hence, in practice, we will probably want a smaller value for <code>maxwait</code>, and we will want to add fault detection and mitigation to the application.
Fault handling will be addressed in a later blog. Here we assume no such faults.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="availability-challenge">Availability challenge<a href="https://www.lf-lang.org/blog/decentralized-consistency/#availability-challenge" class="hash-link" aria-label="Direct link to Availability challenge" title="Direct link to Availability challenge">​</a></h4>
<p>Even without faults, however, setting <code>maxwait</code> to <code>forever</code> creates problems when only the lidar input is expected (50ms, 150ms, 250ms, etc): the controller cannot process that input until an input from the radar comes, because <code>maxwait</code> will never expire. For example, if the single lidar input comes at time 50ms, it has to wait until time 100ms before being processed. If that input was signaling the presence of a close object, the detection would be delayed by 50ms, which may potentially mean crashing into the object. The automatic emergency braking system must be available, otherwise it might not brake in time to avoid collisions.
The ideal <code>maxwait</code> value for maximum availability in the time instants with only the lidar input is 0, because if a single input is expected, no wait is necessary.</p>
<p>Summing up, consistency for sensor fusion requires <code>maxwait = forever</code> when inputs from both sensors are expected (or some finite value for fault tolerance), while availability calls for <code>maxwait = 0</code> when only the lidar input is coming. The two values are at odds, and any value in between would mean sacrificing both properties at the same time.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic-adjustment-of-maxwait">Dynamic adjustment of <code>maxwait</code><a href="https://www.lf-lang.org/blog/decentralized-consistency/#dynamic-adjustment-of-maxwait" class="hash-link" aria-label="Direct link to dynamic-adjustment-of-maxwait" title="Direct link to dynamic-adjustment-of-maxwait">​</a></h3>
<p>The knowledge of the timing properties of the application under analysis enables the <em>a priori</em> determination of the time instants when both inputs are expected and those when only the lidar has new data available.
Lingua Franca allows to dynamically change the <code>maxwait</code> in the reaction body using the <code>lf_set_fed_maxwait</code> API, that takes as input parameter the new <code>maxwait</code> value to set.
This capability of the language permits the automatic emergency braking federate to:</p>
<ul>
<li>start with <code>maxwait</code> statically set to <code>forever</code> (or some finite value for fault tolerance), because at time 0 (startup) both sensors produce data;</li>
<li>set <code>maxwait</code> to 0 after processing both inputs with the same logical time, because the next data will be sent by the lidar only;</li>
<li>set <code>maxwait</code> back to <code>forever</code> after processing the radar input alone, because the next data will be sent by both sensors.</li>
</ul>
<p>This dynamic solution guarantees both consistency and availability as long as lidar data arrives within 50 ms.
The implementation and the instantiation of the <code>AutomaticEmergencyBraking</code> reactor are shown below:</p>
<pre class="shiki"><code>reactor AutomaticEmergencyBraking {
  input lidar_in: float
  input radar_in: float
  output brake: int
  state n_invocs: int = 0

  reaction (lidar_in, radar_in) -&gt; brake {=
    if (lidar_in-&gt;is_present &amp;&amp; radar_in-&gt;is_present) {
      if (sensor_fusion(lidar_in-&gt;value, radar_in-&gt;value) {
        printf("Sensors detect a close object -&gt; signaling braking\n");
        lf_set(brake, 1);
      }
    } else if (lidar_in-&gt;is_present) {
      if (lidar_analysis(lidar_in-&gt;value)) {
        printf("Lidar has detected close object -&gt; signaling braking\n");
        lf_set(brake, 1);
      }
    }

    self-&gt;n_invocs++;
    if (self-&gt;n_invocs % 2) {
      lf_set_fed_maxwait(0);
    } else {
      lf_set_fed_maxwait(FOREVER);
    }
  =} tardy {=
    printf("STP violation on AEB\n");
  =} deadline(100ms) {=
    printf("AEB deadline violated\n");
  =}

  federated reactor {
    lidar = new Lidar()
    radar = new Radar()
    
    @maxwait(forever)
    aeb = new AutomaticEmergencyBraking()
    
    brake = new BrakingSystem()

    lidar.lidar_data -&gt; aeb.lidar_in
    radar.radar_data -&gt; aeb.radar_in
    aeb.brake -&gt; brake.signal
  }
}
</code></pre>
<p>The <code>sensor_fusion()</code> function combines the data and returns <code>true</code> if braking is needed.
The <code>lidar_analysis()</code> function uses only lidar data to make a (presumably more conservative) decision.
The <code>n_invocs</code> integer state variable counts the number of times the reaction of the <code>AutomaticEmergencyBraking</code> reactor is invoked. This variable is used to determine how many inputs the reaction expects to see at the next invocation and set the <code>maxwait</code> accordingly. Even invocation numbers mean that the next reaction invocation will happen with both sensor inputs present, so <code>maxwait</code> is set to <code>forever</code>; with odd invocation numbers, the next reaction invocation will see new data from the lidar only, and <code>maxwait</code> is then set to 0.</p>
<p>Clearly, detecting and handling faults would be needed in practical implementation.
This will be the topic of a subsequent blog.</p>]]></content>
        <author>
            <name>Francesco Paladino</name>
            <uri>https://dblp.org/pid/347/8232.html</uri>
        </author>
        <author>
            <name>Edward A. Lee</name>
            <uri>http://people.eecs.berkeley.edu/~eal/</uri>
        </author>
        <author>
            <name>Ravi Akella</name>
            <uri>https://www.linkedin.com/in/ravicakella/</uri>
        </author>
        <category label="lingua franca" term="lingua franca"/>
        <category label="federation" term="federation"/>
        <category label="decentralized" term="decentralized"/>
        <category label="consistency" term="consistency"/>
        <category label="maxwait" term="maxwait"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Working with Deadlines]]></title>
        <id>https://www.lf-lang.org/blog/deadlines/</id>
        <link href="https://www.lf-lang.org/blog/deadlines/"/>
        <updated>2025-08-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[SensorProcessorActuator diagram]]></summary>
        <content type="html"><![CDATA[<p><img decoding="async" loading="lazy" alt="SensorProcessorActuator diagram" src="https://www.lf-lang.org/assets/images/SensorProcessorActuator-afa90dcb5edb4cdb7f404e307b3a9ef3.svg" width="363" height="114" class="img_ev3q"></p>
<p><a href="https://www.lf-lang.org/docs/writing-reactors/deadlines/">Deadlines</a> in Lingua Franca serve three purposes: they specify real-time requirements, guide scheduling, and provide fault handlers to invoke when real-time requirements are not met.
But they can be subtle to use, and, do not guide scheduling as much as we would like.
This blog outlines the current state of affairs and lays out ongoing work to improve the situation.</p>
<p>A deadline specifies that the physical time at which a reaction <em>starts</em> minus the logical time of that reaction (a time difference called the <strong>lag</strong>) should not exceed some threshold. If it does, then the <strong>deadline violation handler</strong> is invoked rather than the regular reaction.</p>
<p>Deadlines expose a number of scheduling subtleties because unrelated reactions can cause a deadline violation.
Moreover, many users wonder why the deadline refers to the physical time at which a reaction <em>starts</em> rather than the time at which it <em>ends</em>.
Here, we explain some of the subtleties.</p>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="typical-deadline-pattern">Typical Deadline Pattern<a href="https://www.lf-lang.org/blog/deadlines/#typical-deadline-pattern" class="hash-link" aria-label="Direct link to Typical Deadline Pattern" title="Direct link to Typical Deadline Pattern">​</a></h2>
<p>The diagram above depicts a typical pattern, where a periodic reaction polls sensor data, a <code>Processor</code> reactor processes the data, and an <code>Actuator</code> reactor produces some response.
An <strong>end-to-end</strong> deadline is specified as follows (illustrated in the C target):</p>
<pre class="shiki"><code>reactor Actuator(limit: time = 50 ms) {
  input inp:int
  reaction(inp) {=
    // Regular reaction.
    lf_print("Met deadline. Received %d.",  inp-&gt;value);
  =} deadline (limit) {=
    // Deadline violation handler.
    lf_print("******* Missed deadline! Received %d.", inp-&gt;value);
  =}
}
</code></pre>
<p>The deadline shows up in the diagram with a stopwatch symbol.</p>
<p>In this example, because of the timer in the <code>Sensor</code> reactor, the logical times of the events, relative to the start time, are 0, 200 ms, 400 ms, etc., for all reactions.
If the <code>Actuator</code> reaction is invoked at a relative physical time greater than 50 ms, 250 ms, 450 ms, etc., then the deadline violation handler will be invoked rather than the regular reaction.
It will print "******* Missed deadline!" rather than "Met deadline."</p>
<p>This deadline is an <strong>end-to-end</strong> deadline because it accounts for any overhead in invoking the sensor, processing its data, communicating between reactors, and scheduling reactions.
It does not account for any processing done in the <code>Actuator</code> reaction; the intent is that this be a quick driver, not doing a significant amount of processing.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="why-does-a-deadline-constrain-the-start-time-of-a-reaction-rather-than-the-end-time">Why does a deadline constrain the start time of a reaction rather than the end time?<a href="https://www.lf-lang.org/blog/deadlines/#why-does-a-deadline-constrain-the-start-time-of-a-reaction-rather-than-the-end-time" class="hash-link" aria-label="Direct link to Why does a deadline constrain the start time of a reaction rather than the end time?" title="Direct link to Why does a deadline constrain the start time of a reaction rather than the end time?">​</a></h3>
<p>In a typical usage, it may not make sense to actuate based on late data, so we don't want to execute the regular reaction only to then discover that the deadline was violated.
Hence, in this usage, specifying a deadline on the completion of the <code>Actuator</code> reaction would not make sense.</p>
<p>Specifying a deadline on the completion the <code>Processor</code> reaction would also not make sense.
Usually, nobody cares when processing completes; we only care when the results have an effect in the real world.
If we specified only a completion-time deadline for the <code>Processor</code> reaction, then nothing would constrain when the <code>Actuator</code> reaction is invoked.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="specifying-a-deadline-on-completion-time">Specifying a Deadline on Completion Time<a href="https://www.lf-lang.org/blog/deadlines/#specifying-a-deadline-on-completion-time" class="hash-link" aria-label="Direct link to Specifying a Deadline on Completion Time" title="Direct link to Specifying a Deadline on Completion Time">​</a></h2>
<p>Although the above pattern is typical, it is not uncommon to actually want to specify a deadline on a completion time.
Fortunately, this can be easily done with the pattern shown below:</p>
<p><img decoding="async" loading="lazy" alt="CheckDeadline diagram" src="https://www.lf-lang.org/assets/images/CheckDeadline-f97a3e52d0db8162349f735596399cb9.svg" width="278" height="162" class="img_ev3q"></p>
<p>The <code>Check</code> reactor may be specified as follows:</p>
<pre class="shiki"><code>reactor Check(exec = 10 ms, limit: time = 50 ms) {
  input inp:int
  reaction(inp) {=
    lf_sleep(self-&gt;exec);
    lf_print("Received %d.", inp-&gt;value);
  =}
  reaction(inp) {=
    lf_print("Met deadline.");
  =} deadline (limit) {=
    lf_print("******* Missed deadline!");
  =}
}
</code></pre>
<p>This reactor has an <code>exec</code> parameter that specifies an (approximate) execution time, in this test case realized using <code>lf_sleep</code>.
It has a second reaction triggered by the same input that has a deadline given by the <code>limit</code> parameter.
If <code>limit</code> is enough larger than <code>exec</code>, then the deadline will be met.
Otherwise, it will be violated.</p>
<p>This pattern works because reactions belonging to the same reactor are not allowed to execute concurrently (because this would create race conditions accessing state variables). They must execute in sequence, in the order in which they are defined. The numbering in the diagram indicates this ordering.</p>
<p>When an input arrives, both reactions will be triggered.
But because the reactions must execute in the sequence that they are defined, a constraint on the start time of the second reaction is effectively a deadline on the completion time of the first reaction.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="what-keeps-other-reactions-from-executing-between-the-invocation-of-the-first-reaction-and-the-invocation-of-the-second">What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?<a href="https://www.lf-lang.org/blog/deadlines/#what-keeps-other-reactions-from-executing-between-the-invocation-of-the-first-reaction-and-the-invocation-of-the-second" class="hash-link" aria-label="Direct link to What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?" title="Direct link to What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?">​</a></h3>
<p>Ideally, the LF scheduler would be using an <strong>earliest deadline first</strong> (<strong>EDF</strong>) scheduling policy.
Under an EDF scheduling policy, upon completion of the first reaction, the second reaction will have a priority based on the time remaining until its deadline is violated.
Under EDF, only another reaction that is <em>also</em> at risk of violating its deadline could execute between these two.
However, LF does not (yet) implement EDF.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="scheduling">Scheduling<a href="https://www.lf-lang.org/blog/deadlines/#scheduling" class="hash-link" aria-label="Direct link to Scheduling" title="Direct link to Scheduling">​</a></h2>
<p>As of version 0.10.1, the default schedulers in all targets of LF have significant limitations dealing with deadlines and do not implement EDF scheduling.
Here, we explain how scheduling works in version 0.10.1 and then outline research efforts towards achieving EDF scheduling.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="level-scheduling">Level scheduling<a href="https://www.lf-lang.org/blog/deadlines/#level-scheduling" class="hash-link" aria-label="Direct link to Level scheduling" title="Direct link to Level scheduling">​</a></h3>
<p>The schedulers all use a <strong>level scheduling</strong> heuristic to ensure that all precedences have been satisfied when a reaction is invoked.
At each tag (logical time and microstep), several reactions may be triggered.
If there are no dependencies between these reactions, and if there is more than one worker thread, then reactions may be invoked in parallel.
But the scheduler has to ensure that precedences are satisfied.</p>
<p>A reaction <code>r1</code> has precedence over a reaction <code>r2</code> if there is a path (without <code>after</code> delays) from outputs that <code>r1</code> writes to to inputs that <code>r2</code> uses.
In addition, if <code>r1</code> and <code>r2</code> belong to the same reactor, and <code>r1</code> is defined before <code>r2</code>, then <code>r1</code> has precedence.
If <code>r1</code> has precedence over <code>r2</code>, then <code>r1</code> must complete before <code>r2</code> can start.</p>
<p>For efficiency, the default schedulers use a conservative approach called "level scheduling."
At compile time, the dependencies between reactions are analyzed, and an acyclic precedence graph (APG) is constructed.
The <strong>level</strong> of a reaction <code>r</code> is defined as the length of the largest upstream chain of reactions that have precedence over <code>r</code>.
If no reaction has precedence over <code>r</code>, its level is zero.
If exactly one reaction has precedence over <code>r</code>, and that reaction does not depend on other reactions, then <code>r</code> has level one. Etc.</p>
<p>The default schedulers all require that all reactions with level <em>n</em> complete before any reaction with level <em>n</em> + 1 can begin.
This constraint can cause unexpected deadline violations.</p>
<p>Consider program with the following structure:</p>
<p><img decoding="async" loading="lazy" alt="ParallelSensorProcessorActuator diagram" src="https://www.lf-lang.org/assets/images/ParallelSensorProcessorActuator-eaedffcd19a6df0845a907726e0d015f.svg" width="380" height="212" class="img_ev3q"></p>
<p>Suppose that <code>p1</code> has an execution time of 60 ms and <code>p2</code> has an execution time of 10 ms.
Then we might expect the deadline at <code>a1</code> to be violated and the deadline at <code>a2</code> to be met.
But this is not what happens.
The reactions in <code>a1</code> and <code>a2</code> both have level 2.
Because of the level scheduling, the reactions in <em>both</em> <code>p1</code> and <code>p2</code>, which have level 1, must complete before either actuator can be invoked.
Hence, both deadlines are violated.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="federated-execution">Federated Execution<a href="https://www.lf-lang.org/blog/deadlines/#federated-execution" class="hash-link" aria-label="Direct link to Federated Execution" title="Direct link to Federated Execution">​</a></h3>
<p>One way to get around the level-scheduling limitation is to make the program federated, splitting it into separate processes, each of which will have its own scheduler, as shown here:</p>
<p><img decoding="async" loading="lazy" alt="FederatedSensorProcessorActuator diagram" src="https://www.lf-lang.org/assets/images/FederatedSensorProcessorActuator-5b123baf8fe678870d685ce3b4c9bcd5.svg" width="404" height="326" class="img_ev3q"></p>
<p>Here, <code>pa1</code> will consistently miss deadlines (because of the <code>exec</code> parameter value of 60 ms), whereas <code>pa2</code> will consistently meet the deadline. This structure is defined by the following code:</p>
<pre class="shiki"><code>import Sensor, Processor, Actuator from "SensorProcessorActuator.lf"

reactor ProcessorActuator(exec = 10 ms, limit = 50 ms) {
  input sensor: int
  p = new Processor(exec = exec)
  a = new Actuator(limit = limit)
  sensor -&gt; p.inp
  p.out -&gt; a.inp
}

federated reactor {
  s = new Sensor()
  pa1 = new ProcessorActuator(exec = 60 ms)
  pa2 = new ProcessorActuator()
  s.out -&gt; pa1.sensor
  s.out -&gt; pa2.sensor
}
</code></pre>
<p>This can be also be made with two federates rather than three, as shown here:</p>
<p><img decoding="async" loading="lazy" alt="FederatedSmaller diagram" src="https://www.lf-lang.org/assets/images/FederatedSmaller-ee9cda00b2d5ad9dbe7e358e7d0d031e.svg" width="657" height="238" class="img_ev3q"></p>
<p>Some care is needed in this case because the code generator inserts a <code>NetworkSender</code> reactor, as shown below:</p>
<p><img decoding="async" loading="lazy" alt="federate__spa diagram" src="https://www.lf-lang.org/assets/images/federate__spa-b0673045f993c172bcca6356067f4479.svg" width="650" height="224" class="img_ev3q"></p>
<p>This is a code-generated Lingua Franca file for the <code>spa</code> federate alone.
In this case, the reaction in the <code>NetworkSender</code> will have the same level as the reaction in the <code>Processor</code> and hence may get delayed, causing the deadline to be missed at the <code>pa</code> federate.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="early-deadline-violation-detection">Early Deadline Violation Detection<a href="https://www.lf-lang.org/blog/deadlines/#early-deadline-violation-detection" class="hash-link" aria-label="Direct link to Early Deadline Violation Detection" title="Direct link to Early Deadline Violation Detection">​</a></h2>
<p>A deadline violation handler is invoked when a reaction is to be <em>started</em> late.
Above, we explained how to react to a late <em>completion time</em> of a reaction, but the handler is not invoked until the reaction actually completes.
What if you need to react as soon as you know that the completion time will be late?
Here we describe three complementary mechanisms that can react sooner.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="reactions-that-monitor-their-execution-time">Reactions that Monitor Their Execution Time<a href="https://www.lf-lang.org/blog/deadlines/#reactions-that-monitor-their-execution-time" class="hash-link" aria-label="Direct link to Reactions that Monitor Their Execution Time" title="Direct link to Reactions that Monitor Their Execution Time">​</a></h3>
<p>The <a href="https://www.lf-lang.org/reactor-c/group__API.html#gab3a04dd0a1581844829b28686b6b3c53" target="_blank" rel="noopener noreferrer"><code>lf_check_deadline</code></a> function in the <a href="https://www.lf-lang.org/reactor-c/group__API.html" target="_blank" rel="noopener noreferrer">reactor API</a> can be used to write a reaction that monitors its own execution time against a deadline and invokes its deadline violation handler as soon as it detects that the execution time has exceeded the deadline.
This mechanism works when the reaction is <em>started</em> on time, but when we want it to terminate its execution when it cannot <em>complete</em> on time.
A nice example of this is given in the <a href="https://github.com/lf-lang/playground-lingua-franca/blob/main/examples/C/src/deadlines/AnytimePrime.lf" target="_blank" rel="noopener noreferrer">AnytimePrime.lf</a> example in the <a href="https://github.com/lf-lang/playground-lingua-franca/blob/main/examples/C/src/deadlines/README.md" target="_blank" rel="noopener noreferrer">deadline collection</a> of the <a href="https://github.com/lf-lang/playground-lingua-franca/tree/main" target="_blank" rel="noopener noreferrer">LF playground repo</a>.
It computes as many prime numbers as it can before exceeding a time budget and then aborts.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="federates-as-watchdog-like-monitors">Federates as Watchdog-Like Monitors<a href="https://www.lf-lang.org/blog/deadlines/#federates-as-watchdog-like-monitors" class="hash-link" aria-label="Direct link to Federates as Watchdog-Like Monitors" title="Direct link to Federates as Watchdog-Like Monitors">​</a></h3>
<p>The <a href="https://www.lf-lang.org/docs/next/writing-reactors/distributed-execution#decentralized-coordination" target="_blank" rel="noopener noreferrer">decentralized coordinator</a> for federated execution gives a convenient mechanism for creating a form of watchdog-like monitor that runs in a separate process or even on a separate machine.
This can give a robust detection of a failure because the monitor can be put on a separate machine from the process being monitored.</p>
<p>Consider the following example:</p>
<p><img decoding="async" loading="lazy" alt="FederatedWatchdog diagram" src="https://www.lf-lang.org/assets/images/FederatedWatchdog-eb5871ee989a43e2c5b0d87592a82f18.svg" width="534" height="202" class="img_ev3q"></p>
<pre class="shiki"><code>target C {
  coordination: decentralized
}
import Sensor, Processor, Actuator from "SensorProcessorActuator.lf"

reactor Monitored(exec = 10 ms) {
  output complete:int
  s = new Sensor()
  p = new Processor(exec = exec)
  a = new Actuator()
  s.out -&gt; p.inp
  p.out -&gt; a.inp
  p.out -&gt; complete
}

reactor Monitor(STA: time = 50 ms) {
  input inp:int
  timer t(0, 200 ms)

  reaction(t, inp) {=
    if (!inp-&gt;is_present) {
      lf_print("%s: ******* Failed to receive input on time at logical time " PRINTF_TIME,
          lf_reactor_name(self), lf_time_logical_elapsed());
    } else {
      lf_print("%s: Monitor OK at logical time " PRINTF_TIME,
          lf_reactor_name(self), lf_time_logical_elapsed());
    }
  =} STAA(0) {=
    lf_print("%s: ******* Monitor received late input.", lf_reactor_name(self));
  =}
}

federated reactor {
  @label("exec = 60 ms")
  m = new Monitored(exec = 60 ms)
  @label("STA = 50 ms")
  w = new Monitor()
  m.complete -&gt; w.inp
}
</code></pre>
<p>The <code>Monitored</code> reactor is simply a federate containing the sensor-processor-actuator chain.
It is just like above except that it also copies the output of the processor to its own <code>complete</code> output.</p>
<p>The <code>Monitor</code> federate has a timer that exactly matches the <code>Sensor</code> timer in offset and period.
The <code>Monitor</code> expects an input from <code>Monitored</code> at each tick of this timer.
The <a href="https://www.lf-lang.org/docs/next/writing-reactors/distributed-execution#safe-to-advance-sta" target="_blank" rel="noopener noreferrer"><code>STA</code> parameter</a> (<strong>safe to advance</strong>) specifies that it is safe to advance the federate's logical time to the logical time of the timer tick when physical time exceeds that logical time plus the <code>STA</code> even if input status is unknown.
The <code>STA</code> is set to 50 ms, so, at physical times 50 ms, 250 ms, 450 ms, etc. after the start time, if an input has not arrived, then the input will be assumed to be absent and the <code>Monitor</code>'s reaction will be invoked.
The reaction, therefore, just has to check whether the input is present.
If it is, then the <code>Monitored</code> federate is alive and well and its processor output was received by the <code>Monitor</code> within 50 ms.
Otherwise, something has gone wrong that has led to a delay greater than 50 ms.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="watchdogs">Watchdogs<a href="https://www.lf-lang.org/blog/deadlines/#watchdogs" class="hash-link" aria-label="Direct link to Watchdogs" title="Direct link to Watchdogs">​</a></h3>
<p>An experimental <code>watchdog</code> mechanism is available in LF and is described by
<a href="https://ieeexplore.ieee.org/document/10693560" target="_blank" rel="noopener noreferrer">Asch, et al., Software-Defined Watchdog Timers for Cyber-Physical Systems</a>.
A <code>watchdog</code> specifies a handler that is invoked if, after the watchdog is started using the <a href="https://www.lf-lang.org/reactor-c/group__API.html#ga82bf2c7bd91fdf03b357914cf875dbb9" target="_blank" rel="noopener noreferrer"><code>lf_watchdog_start</code></a> function in the <a href="https://www.lf-lang.org/reactor-c/group__API.html" target="_blank" rel="noopener noreferrer">reactor API</a>, the watchdog is not stopped or restarted within the specified amount of physical time.</p>
<p>A typical usage is to start a watchdog before a potentially problematic reaction is invoked and then stop the watchdog upon completion of the reaction.
As soon as the reaction takes too long to complete, the watchdog handler will be invoked.</p>
<p>Using watchdogs is tricky because the watchdog handler requires a mutual exclusion lock in order to safely access state variables (see <a href="https://ieeexplore.ieee.org/document/10693560" target="_blank" rel="noopener noreferrer">Asch, et al.</a>.
For this reason, federates (or, in the future, enclaves) are preferred.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="ongoing-research">Ongoing Research<a href="https://www.lf-lang.org/blog/deadlines/#ongoing-research" class="hash-link" aria-label="Direct link to Ongoing Research" title="Direct link to Ongoing Research">​</a></h2>
<p>Several significant efforts are under way to improve the real-time behavior of LF and to guide scheduling using deadlines.
Some early work is reported in <a href="https://ieeexplore.ieee.org/document/10697337" target="_blank" rel="noopener noreferrer">Paladino, et al., Layered Scheduling: Toward Better Real-Time Lingua Franca</a>.
That work makes use of an early version of the enclaves mechanism, described below.
It leverages priority-based thread scheduling in the standard Linux kernel.
Here, we focus on what is currently available (as of version 0.10.1 and 0.10.2-SNAPSHOT) in LF.</p>
<p>The overarching goal is that reactions with deadlines that are closest to expiring should be given priority and executed as soon as all their precedences have been satisfied.
I.e., ideally, LF would implement EDF.
But it does not. Yet.
Here, we describe some steps towards achieving such a scheduling policy with LF.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="gedf_np-scheduler">GEDF_NP Scheduler<a href="https://www.lf-lang.org/blog/deadlines/#gedf_np-scheduler" class="hash-link" aria-label="Direct link to GEDF_NP Scheduler" title="Direct link to GEDF_NP Scheduler">​</a></h3>
<p>An early experiment is a scheduler called <code>GEDF_NP</code>, which has some initial efforts towards achieving EDF scheduling, although it has many limitations.
This scheduler is specified using a target property as follows:</p>
<pre class="shiki"><code>target C {
  timeout: 1 s,
  scheduler: GEDF_NP
}
</code></pre>
<p>Unlike the default scheduler, this one takes deadlines into account when sorting events on the event queue.
Consider the following example:</p>
<p><img decoding="async" loading="lazy" alt="MoreParallelSensorProcessorActuator diagram" src="https://www.lf-lang.org/assets/images/MoreParallelSensorProcessorActuator-3e799e626be9c646de921253f2d98007.svg" width="379" height="234" class="img_ev3q"></p>
<p>For the purposes of sorting events on the event queue, the <code>GEDF_NP</code> scheduler propagates deadlines upstream from reactions where they are declared.
In this example, the processors and sensors inherit the deadlines of the actuators that they drive.
Hence, sensor <code>s2</code> will be treated as if it has a deadline of 40 ms, while <code>s1</code> will be treated as if it has a deadline of 50 ms.</p>
<p>The timers in each of these sensors have identical periods and offsets, so their events would normally not have any particular ordering.
The <code>GEDF_NP</code> scheduler, however, for events with identical tags, gives priority to those with earlier deadlines.
In the above example, it will pull the timer event for <code>s2</code> from the event queue and process all reactions that this triggers before pulling the timer event for <code>s1</code>.
As a consequence, it overcomes the level-scheduling limitation, and <code>a2</code> will meet its deadline.</p>
<p>There are several downsides to this approach, however.</p>
<p>First, it sacrifices parallelism.
In the above example, suppose that both Processor reactors have an execution time of 30 ms.
In a dual-core (or more) processor, it should be possible to meet both deadlines.
However, the <code>GEDF_NP</code> scheduler processes all the reactions triggered by the timer in <code>s2</code> before even fetching the timer event for <code>s1</code>.
As a consequence, it will miss the deadline in <code>a1</code>.
If the deadlines are made identical, however, both 50 ms, then both deadlines will be met if there are two cores.</p>
<p>Second, the <code>GEDF_NP</code> scheduler only considers (inherited) deadlines when sorting the event queue.
Events that do not pass through the event queue are unaffected.
As a consequence, in the following example, both deadlines are missed, even if the deadlines are identical:</p>
<p><img decoding="async" loading="lazy" alt="ParallelSensorProcessorActuator diagram" src="https://www.lf-lang.org/assets/images/ParallelSensorProcessorActuator2-c31c8e04487dbef16756335f10d45073.svg" width="380" height="212" class="img_ev3q"></p>
<p>At each tag, there is only one event, the one for the timer in the <code>s</code> sensor.
The reaction in <code>s</code> will have an inherited deadline of 40 ms (the smaller of the two downstream deadlines), but there is no other competing event with the same tag, so the <code>GEDF_NP</code> scheduler will have no effect.</p>
<p>Third, the <code>GEDF_NP</code> scheduler underperforms the default scheduler by a considerable margin.
It is slower.</p>
<p>As a consequence of these limitations, the <code>GEDF_NP</code> scheduler is likely to be retired.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="enclaves">Enclaves<a href="https://www.lf-lang.org/blog/deadlines/#enclaves" class="hash-link" aria-label="Direct link to Enclaves" title="Direct link to Enclaves">​</a></h3>
<p>As of version 0.10.2-SNAPSHOT, the development version after the 0.10.1 release, there is some support for <strong>scheduling enclaves</strong>.
These are similar to federates, in that they create separated scheduling domains, but they execute within the same process as their container.
Such an enclave can be created using an <code>@enclave</code> annotation, as shown here:</p>
<pre class="shiki"><code>main reactor {
  ...
  @enclave
  pa = new ProcessorActuator(exec = 60 ms)
  ...
}
</code></pre>
<p>The resulting diagram shows a red outline for the enclave:</p>
<p><img decoding="async" loading="lazy" alt="EnclavedProcessorActuator diagram" src="https://www.lf-lang.org/assets/images/EnclavedProcessorActuator-a2d784a5bc35ae442795b17fd0c468ad.svg" width="489" height="247" class="img_ev3q"></p>
<p>In this case, as with the federate execution, the deadline will be systematically met at actuator <code>a1</code> but missed at actuator <code>pa.a</code>.</p>
<p>As with federated execution, there is a subtlety because an <code>EnclaveCommunication</code> reactor is inserted on the communication path to the enclave.
It has two reactions separated by a logical action, so, for this particular structure, the reaction that sends data to <code>pa</code> will have the same level as the reaction in <code>p1</code>.</p>
<p>Enclaves realize the equivalent of centralized coordination, which makes sense because they all run in the same process.
However, this means that the <code>FederatedWatchdog</code> example cannot be converted as-is to use enclaves.
A similar monitor, however, can be created using a physical connection.</p>
<p>The goal of enclaves is to achieve the same decoupling as with federates, but with all enclaves executing in the same process and communicating via shared memory.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusions">Conclusions<a href="https://www.lf-lang.org/blog/deadlines/#conclusions" class="hash-link" aria-label="Direct link to Conclusions" title="Direct link to Conclusions">​</a></h2>
<p>Today, the deadline mechanism in LF provides a useful mechanism for detecting and reacting to timing anomalies.
But LF does not yet have an effective scheduler that prioritizes reactions with earlier deadlines.</p>]]></content>
        <author>
            <name>Edward A. Lee</name>
            <uri>http://people.eecs.berkeley.edu/~eal/</uri>
        </author>
        <author>
            <name>Ravi Akella</name>
            <uri>https://www.linkedin.com/in/ravicakella/</uri>
        </author>
        <author>
            <name>Francesco Paladino</name>
            <uri>https://dblp.org/pid/347/8232.html</uri>
        </author>
        <author>
            <name>Keiichi Bando</name>
            <uri>https://github.com/keiichibando</uri>
        </author>
        <category label="lingua franca" term="lingua franca"/>
        <category label="deadlines" term="deadlines"/>
        <category label="real-time" term="real-time"/>
        <category label="scheduling" term="scheduling"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Lingo Package Manager]]></title>
        <id>https://www.lf-lang.org/blog/lingo/</id>
        <link href="https://www.lf-lang.org/blog/lingo/"/>
        <updated>2023-12-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Banner]]></summary>
        <content type="html"><![CDATA[<p><img decoding="async" loading="lazy" alt="Banner" src="https://www.lf-lang.org/assets/images/lingo-release-post-0f9f5df9300344318ef5c55c0e307d85.png" width="1265" height="230" class="img_ev3q"></p>
<p>Programming languages like Python, Rust, or JavaScript are popular not only because of particular language features, but also thanks to the quality of the tools and packages they offer access to.
A good and mature ecosystem includes features such as developer support, mainly through IDEs or LSPs. Lingua Franca already shines in this area with its VSCode integration that offers functionality like code highlighting, error handling, build support, and diagram synthesis. Another important aspect of a modern language's ecosystem concerns package management. Although it is possible to import reactors from files in the local file system, support for packaging in Lingua Franca is still in its infancy.</p>
<!-- -->
<p>The Lingua Franca team is therefore pleased to present <strong>Lingo</strong>, a new package manager and build tool for Lingua Franca. While we still have a long list of features that we want Lingo to have (including the ability to publish packages), you can already do quite a few useful things with it.
For instance, you can easily set up new Lingua Franca projects with <code>lingo init --language</code>, which creates a <code>Lingo.toml</code> and a small hello world program under <code>src/Main.lf</code>. The <code>Lingo.toml</code> specifies a set of apps that are executable LF programs. Apps can be configured with additional build and target properties.</p>
<div class="language-toml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-toml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[package]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = "Showcase"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">version = "0.1.0"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[properties]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[[app]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = "Main"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">main = "./src/Main.lf"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">target = "Cpp"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">platform = "Native"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[app.dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[app.properties]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>To build this app, simply run <code>lingo build</code> and Lingo will start building all the apps specified in the Lingo.toml. You can then find your build result in <code>./target/bin/Main</code> or simply run <code>lingo run</code> if you want to execute the result. The command <code>lingo clean</code> is available for cleaning up build items.</p>
<p>Lingo uses an internal concept called backends to wrap the different tool chains of targets. At the moment there is a <code>CMake</code> (Cpp), <code>pnpm</code>, <code>npm</code> (Typescript) and a <code>lfc</code> backend, but the <code>lfc</code> backend is a temporary solution until a backend is written for all the different toolchains. Therefore, it is important to know that not all targets and functions are officially supported yet. Especially the creation of federated or embedded programs is not yet supported.</p>
<p>We highly encourage the use of Lingo as it already improves the quality of life when developing LF applications and gives us valuable insights into the needs of developers. But you may be wondering how you can get Lingo. Lingo is published on crates.io. To install it, simply run:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cargo install lingua-franca</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>and <code>lingo</code> should show up in your <code>$PATH</code>. If you have a question, problem or bug, please submit a issue <a href="https://github.com/lf-lang/lingo/issues" target="_blank" rel="noopener noreferrer">here</a>.</p>]]></content>
        <author>
            <name>Tassilo Tanneberger</name>
            <uri>https://github.com/tanneberger</uri>
        </author>
        <author>
            <name>Marten Lohstroh</name>
            <uri>https://github.com/lhstrh</uri>
        </author>
        <category label="lingo" term="lingo"/>
        <category label="lingua franca" term="lingua franca"/>
        <category label="packaging" term="packaging"/>
        <category label="build tool" term="build tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[New Lingua Franca Website]]></title>
        <id>https://www.lf-lang.org/blog/docusaurus/</id>
        <link href="https://www.lf-lang.org/blog/docusaurus/"/>
        <updated>2023-12-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We have a new website! Most importantly, this website is the home of our documentation.]]></summary>
        <content type="html"><![CDATA[<p>We have a new website! Most importantly, this website is the home of our documentation.</p>
<p>After careful consideration, we realized that our original website had become overly intricate to maintain due to its numerous customizations and dependencies. Writing comprehensive documentation is already a challenging and time-consuming task, and we were keen on avoiding additional complexity that could hinder our progress. Additionally, we had a wishlist of new features, including the ability to version our documentation, incorporate a blog page, and provide support for <a href="https://mdxjs.com/" target="_blank" rel="noopener noreferrer">MDX</a>. In pursuit of solutions, we explored various options.</p>
<!-- -->
<p><img decoding="async" loading="lazy" alt="LinguaFrancasaurus" src="https://www.lf-lang.org/assets/images/lf-and-docusaurus-9c56b96de8d71e312c166607f923559f.svg" width="760" height="165" class="img_ev3q"></p>
<p>Fortunately, we discovered a framework that encompassed all the features we desired: <a href="https://docusaurus.io/" target="_blank" rel="noopener noreferrer">Docusaurus</a>. The adoption of this framework allowed us to streamline our infrastructure significantly. Remarkably, we were able to retain essential functionalities, such as our <a href="https://www.algolia.com/" target="_blank" rel="noopener noreferrer">Algolia</a>-based search bar and Markdown-based documentation pages, which are now more accessible for reading and editing.</p>
<p>Despite initial reservations about the switch, particularly the prospect of rebuilding LF-specific functionalities—such as support for multiple target languages and Lingua Franca syntax highlighting, which demanded a considerable investment of time and effort - we were pleasantly surprised. Docusaurus-native features like Tabs and Tab Groups, coupled with existing third-party libraries like <a href="https://github.com/antfu/shikiji" target="_blank" rel="noopener noreferrer">Shikiji</a>, seamlessly resolved our concerns with minimal adjustments. This not only addressed our specific needs but also considerably eased website maintenance.</p>
<p>We hope that you like the new look and feel! If you have any comments, corrections, or other suggestions for improvement, feel welcome to create an issue <a href="https://github.com/lf-lang/lf-lang.github.io/issues" target="_blank" rel="noopener noreferrer">here</a> or submit a pull request <a href="https://github.com/lf-lang/lf-lang.github.io/pulls" target="_blank" rel="noopener noreferrer">here</a>.</p>]]></content>
        <author>
            <name>axmmisaka</name>
            <uri>https://github.com/axmmisaka</uri>
        </author>
        <author>
            <name>Marten Lohstroh</name>
            <uri>https://github.com/lhstrh</uri>
        </author>
        <category label="docusaurus" term="docusaurus"/>
        <category label="website" term="website"/>
        <category label="lingua franca" term="lingua franca"/>
        <category label="docs" term="docs"/>
    </entry>
</feed>