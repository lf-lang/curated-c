"use strict";(globalThis.webpackChunkdocusaurus_classic_typescript=globalThis.webpackChunkdocusaurus_classic_typescript||[]).push([[38749],{91895:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"decentralized-consistency","metadata":{"permalink":"/blog/decentralized-consistency","source":"@site/blog/2025-10-14-decentralized-consistency.md","title":"Decentralized Consistency","description":"The design of distributed applications in Lingua Franca requires care, particularly if the coordination of the federation is decentralized. The intent of this post is to illustrate and handle the challenges arising from designing distributed applications in Lingua Franca, with the help of two realistic use cases.","date":"2025-10-14T00:00:00.000Z","tags":[{"inline":true,"label":"lingua franca","permalink":"/blog/tags/lingua-franca"},{"inline":true,"label":"federation","permalink":"/blog/tags/federation"},{"inline":true,"label":"decentralized","permalink":"/blog/tags/decentralized"},{"inline":true,"label":"consistency","permalink":"/blog/tags/consistency"},{"inline":true,"label":"maxwait","permalink":"/blog/tags/maxwait"}],"readingTime":13.14,"hasTruncateMarker":true,"authors":[{"name":"Francesco Paladino","title":"Postdoc, UC Berkeley","url":"https://dblp.org/pid/347/8232.html","imageURL":"https://avatars.githubusercontent.com/u/47446988?v=4","key":"fra-p","page":null},{"name":"Edward A. Lee","title":"Professor at UC Berkeley","url":"http://people.eecs.berkeley.edu/~eal/","imageURL":"https://avatars.githubusercontent.com/u/8513334?v=4","key":"eal","page":null},{"name":"Ravi Akella","title":"Sr. Research Engineer, DENSO International America Inc.","url":"https://www.linkedin.com/in/ravicakella/","imageURL":"https://avatars.githubusercontent.com/u/913550?v=4","key":"rcakella","page":null}],"frontMatter":{"slug":"decentralized-consistency","title":"Decentralized Consistency","authors":["fra-p","eal","rcakella"],"tags":["lingua franca","federation","decentralized","consistency","maxwait"]},"unlisted":false,"nextItem":{"title":"Working with Deadlines","permalink":"/blog/deadlines"}},"content":"The design of [distributed applications](/docs/writing-reactors/distributed-execution) in Lingua Franca requires care, particularly if the coordination of the federation is [decentralized](/docs/writing-reactors/distributed-execution#decentralized-coordination). The intent of this post is to illustrate and handle the challenges arising from designing distributed applications in Lingua Franca, with the help of two realistic use cases.\\n\\n{/* truncate */}\\n\\n## Indefinite wait for inputs: aircraft door use case\\nAircraft doors on passenger flights are currently managed manually by flight attendants.\\nBefore takeoff, the flight attendants _arm_ the door; if the door is opened in this state, an evacuation slide is automatically inflated and deployed for emergency evacuation.\\nWhen the aircraft is at a gate, before opening the door, the flight attendants _disarm_ it to avoid the deployment of the evacuation slide.\\nFlight attendants are allowed to disarm the door _only_ when they see through the porthole the ramp that will allow the passengers to disembark the aircraft.\\n\\n![AircraftDoor diagram](../static/img/blog/AircraftDoor.svg)\\n\\nConsider the above Lingua Franca program that implements a simplified system to remotely open an aircraft door that is in the _armed_ state.\\nThe door implements two independent remote services, door _disarming_ and door _opening_, encoded by two different reactions in the `Door` reactor.\\nSuppose the pilot in the cockpit issues a command to open the door.\\nWe would also like to automate the disarming of the door using a camera to verify the presence of a ramp. When the camera determines that the ramp is present, it triggers the disarming service. The camera detection is triggered by the door open command issued from the cockpit.\\n\\nThere are different ways to design and refactor the above system, for example, by removing the direct connection between the `Cockpit` and `Door` reactors. Our design choice is meant to highlight that door _disarming_ and _opening_ are two different and independent remote services triggered by two different commands issued by two different system actors. Therefore, each actor has an independent connection to the door to request its service.\\n\\nThe purpose of the system is to open the door in reaction to the command from the cockpit whether or not a ramp is present. If a ramp is present, it is imperative that the door be disarmed _before_ being opened. Hence, the door, upon receiving the `open` command from the cockpit, should wait for input from the camera before opening.\\n\\nThe order in which messages are processed is crucial in this application. When the _disarm_ and _open_ commands arrive with the same tag, the _disarm_ service needs to be invoked before opening the door, otherwise the escape slide will be erroneously deployed.\\nLingua Franca guarantees determinism in the execution order of reactions with logically simultaneous inputs, and the order is given by the the order of declaration of the reactions inside the reactor. It is then sufficient to declare the `disarm` reaction _before_ the `open` one. The diagram confirms the execution order by labeling the `disarm` reaction with 1 and the `open` reaction with 2.\\n\\nThe problem is that even though the messages are _logically_ simultaneous, they do not arrive at the same _physical_ time. In fact, the `open` command from the cockpit is likely to arrive before the clearance from the camera because the camera realizes an expensive computer vision algorithm. The door, consequently, has to wait for both inputs before invoking the _opening_ service.\\n\\nThis is an example of an application that cannot safely proceed without assurance on its inputs. The following section explains how to obtain the desired behavior in Lingua Franca using the decentralized coordinator (the centralized coordinator automatically provides the required assurance).\\n\\n### Consistency with decentralized coordination\\nThe application is implemented as a federated program with decentralized coordination, which means that the advancement of logical time in each single federate is not subject to approval from any centralized entities, but it is done locally based on the input it receives from the other federates and on its local physical clock.\\n\\nLet us consider the case when the `Door` reactor receives the _open_ command from the `Cockpit` reactor, but not yet the _disarm_ command from the `Camera` reactor. As previously observed, the `Door` cannot proceed to invoke the _opening_ service, because it needs to wait for the `Camera` to send the _disarm_ command.\\nBut how long should it wait?\\n\\nThe decentralized coordinator in\\nLingua Franca allows you to customize this waiting time. Each federate can be assigned an attribute called [`maxwait`](/docs/writing-reactors/distributed-execution#safe-to-advance-sta) that controls how long the federate should wait for inputs from other federates before processing an event, such as an input it has just received.\\nMore precisely, `maxwait` is the maximum amount of time a federate waits before advancing its logical time to some value _t_. Specifically, to advance to logical time _t_, the federate waits until either all inputs are known up to an including time _t_ or its local physical clock exceeds _t_ +`maxwait`.\\nAn input is known up to an including time _t_ if a message with timestamp _t_ or greater has been received on that input port.\\nAt the expiration of the `maxwait`, the federate assumes that any unresolved ports will not receive any messages with timestamps _t_ or earlier.\\nIt can then advance its logical time to _t_.\\n\\nIn our example, we want the door to _wait indefinitely_ for both _disarm_ and _open_ commands to arrive before processing any of them. In Lingua Franca, this is obtained by setting `maxwait` to `forever`. The `Door` reactor cannot safely proceed without assurance about the inputs.\\n\\nThe implementation of the `Door` reactor and its instantiation are shown below:\\n\\n```lf-c\\nreactor Door {\\n  input open: bool\\n  input disarm: bool\\n  state isDisarmed: bool = false\\n  state isOpen: bool = false\\n\\n  reaction(disarm) {=\\n    if (disarm->value) {\\n      self->isDisarmed = true;\\n      printf(\\"Door disarmed\\\\n\\");\\n    } else {\\n      self->isDisarmed = false;\\n      printf(\\"Door armed\\\\n\\");\\n    }\\n  =} tardy {=\\n    printf(\\"STP violation\\\\n\\");\\n    printf(\\"Intended tag: %lld\\\\n\\", disarm->intended_tag);\\n    printf(\\"Current tag: %lld\\\\n\\", lf_time_logical());\\n  =}\\n\\n  reaction(open) {=\\n    if (open->value) {\\n      self->open = true;\\n      printf(\\"Door open\\\\n\\");\\n    } else {\\n      self->open = false;\\n      printf(\\"Door closed\\\\n\\");\\n    }\\n  =} tardy {=\\n    printf(\\"STP violation\\\\n\\");\\n    printf(\\"Intended tag: %lld\\\\n\\", disarm->intended_tag);\\n    printf(\\"Current tag: %lld\\\\n\\", lf_time_logical());\\n  =}\\n}\\n\\nfederated reactor {\\n  c = new Cockpit()\\n  v = new Camera()\\n  \\n  @maxwait(forever)\\n  d = new Door()\\n\\n  c.open -> d.open\\n  c.open -> v.check_ramp\\n  v.ramp_present -> d.disarm\\n}\\n```\\n\\nThe `maxwait` attribute is specified at instantiation time within the main reactor. Right before creating the instance of the `Door` reactor for which we want to set the attribute, we use the `@maxwait` annotation that takes as input the `maxwait` value. \\n\\nThe reactions of the `Door` reactor provide [fault handlers](/docs/writing-reactors/distributed-execution#safe-to-process-stp-violation-handling) that are invoked in case the federate assumed inputs were known up to timestamp _t_ and then later received a message with timestamp _t_ or less. When `maxwait` is `forever`, these fault handlers should never be invoked.\\n\\nFor finite values of `maxwait`, it is always possible for messages to get sufficiently delayed that the fault handlers will be invoked.\\nWhen they are invoked, the current tag will be greater than the intended tag of the message.\\nThis type of fault is called a **safe-to-process** (**STP**) violation because messages are being handled out of tag order.\\nThe intended tag of the input can be accessed as shown in the code above.\\n\\n## Multirate inputs: automatic emergency braking\\n![AutomaticEmergencyBrakingSystem diagram](../static/img/blog/AutomaticEmergencyBrakingSystem.svg)\\n\\nConsider the above Lingua Franca implementation of an automatic emergency braking system, one of the most critical ADAS systems that modern cars are equipped with.\\nThe controller system modeled by the `AutomaticEmergencyBraking` reactor reads data coming from two sensors, a lidar and a radar, and uses both to detect objects or pedestrians that cross the trajectory the car.\\nThis is a _sensor fusion_ problem, where a diversity of sensors is used to get better reliability.\\nWhen one of the two sensors signals the presence of an object at a distance shorter than a configurable threshold, the controller triggers the brake to stop the car and avoid crashing into it.\\n\\nThe sensors are modeled with their own timer that triggers the generation of data. The clocks of all federates are automatically synchronized by the [clock synchronization algorithm](/docs/writing-reactors/distributed-execution#clock-synchronization) of the Lingua Franca runtime (unless this is disabled).\\nTypically, in a real use case of this kind, the clock of sensor devices cannot be controlled by Lingua Franca, but a way to work around this limitation is to resample the data collected by sensors with the timing given by a clock that the runtime can control.\\nThe sensor reactors of our application are then modeling this resampling of sensor data so that alignment of data from the two sensors is well defined and sensor fusion becomes possible.\\n\\nThe lidar sensor has a sampling frequency that is twice that of the radar, as indicated by the timers in the corresponding reactors; the lidar timer has a period of 50ms, while that of the radar 100ms.\\nTheir deadline is equal to their period and is enforced using the dedicated `DeadlineCheck` reactors, following the guidelines of how to [work with deadlines](/blog/deadlines).\\n\\nThe sensor behavior in the application can be simulated for testing purposes in a way that each sensor constantly produces distance values above the threshold (i.e., no objects in the way), and then at a random time it sends a distance value below the threshold, indicating the presence of a close object. When the `AutomaticEmergencyBraking` reactor receives that message, it signals the `BrakingSystem` reactor to brake the car, and the whole system shuts down.\\n\\n### Desired system properties\\nAvailability is a crucial property of this application, because we want the automatic emergency braking system to brake as fast as possible when a close object is detected. Consistency is also necessary, as sensor fusion happens with sensor data produced at the same logical time. Even if this is not implemented in our simplified example, sensor fusion in a more general scenario helps rule out false positives, i.e., cases in which one of the sensors erroneously detects a close object that would induce an unnecessary and dangerous braking. False positives are caused by the weaknesses of the specific sensor. For example, rainy or foggy weather reduces the accuracy of lidar sensors. The key concept is to gather data produced at the same logical time by all sensors and combine them to have a more accurate estimate of possible collisions. Consistency and in-order data processing are then required.\\n\\n#### Consistency challenge\\nThe application is once agin implemented as a federated program with decentralized coordination.\\nConsistency problems may arise when a federate receives data from two or more federates, as it is the case of the `AutomaticEmergencyBraking` reactor.\\nThe controller expects to receive input from both sensors at times 0ms, 100ms, 200ms, etc. Let\'s consider as an example the case where the remote connection between the controller and the radar has a slightly larger delay than that between the controller and the lidar. The lidar input will then always arrive slightly earlier than the radar one. When the controller receives the lidar input, should it process the data immediately, or should it wait for the radar input to come? Sensor fusion requires consistency: if the controller processes the input from the lidar and then the radar data comes, the control action elaborated upon the arrival of the lidar data does not take into account both sensors, even though it should. Hence, in our use case, the `AutomaticEmergencyBraking` reactor needs to wait for both inputs before processing new data.\\n\\nIn our application, if we aim to process all incoming data with the same logical time to realize sensor fusion, then we can set `maxwait = forever` to _wait indefinitely_ for the radar input before processing the radar.\\nNote that this might not be a good choice in this example because if a fault causes one of the sensors to stop sending messages, the ADAS system will stop working.\\nHence, in practice, we will probably want a smaller value for `maxwait`, and we will want to add fault detection and mitigation to the application.\\nFault handling will be addressed in a later blog. Here we assume no such faults.\\n\\n#### Availability challenge\\nEven without faults, however, setting `maxwait` to `forever` creates problems when only the lidar input is expected (50ms, 150ms, 250ms, etc): the controller cannot process that input until an input from the radar comes, because `maxwait` will never expire. For example, if the single lidar input comes at time 50ms, it has to wait until time 100ms before being processed. If that input was signaling the presence of a close object, the detection would be delayed by 50ms, which may potentially mean crashing into the object. The automatic emergency braking system must be available, otherwise it might not brake in time to avoid collisions.\\nThe ideal `maxwait` value for maximum availability in the time instants with only the lidar input is 0, because if a single input is expected, no wait is necessary.\\n\\nSumming up, consistency for sensor fusion requires `maxwait = forever` when inputs from both sensors are expected (or some finite value for fault tolerance), while availability calls for `maxwait = 0` when only the lidar input is coming. The two values are at odds, and any value in between would mean sacrificing both properties at the same time.\\n\\n### Dynamic adjustment of `maxwait`\\nThe knowledge of the timing properties of the application under analysis enables the _a priori_ determination of the time instants when both inputs are expected and those when only the lidar has new data available.\\nLingua Franca allows to dynamically change the `maxwait` in the reaction body using the `lf_set_fed_maxwait` API, that takes as input parameter the new `maxwait` value to set.\\nThis capability of the language permits the automatic emergency braking federate to:\\n\\n* start with `maxwait` statically set to `forever` (or some finite value for fault tolerance), because at time 0 (startup) both sensors produce data;\\n* set `maxwait` to 0 after processing both inputs with the same logical time, because the next data will be sent by the lidar only;\\n* set `maxwait` back to `forever` after processing the radar input alone, because the next data will be sent by both sensors.\\n\\nThis dynamic solution guarantees both consistency and availability as long as lidar data arrives within 50 ms.\\nThe implementation and the instantiation of the `AutomaticEmergencyBraking` reactor are shown below:\\n\\n```lf-c\\nreactor AutomaticEmergencyBraking {\\n  input lidar_in: float\\n  input radar_in: float\\n  output brake: int\\n  state n_invocs: int = 0\\n\\n  reaction (lidar_in, radar_in) -> brake {=\\n    if (lidar_in->is_present && radar_in->is_present) {\\n      if (sensor_fusion(lidar_in->value, radar_in->value) {\\n        printf(\\"Sensors detect a close object -> signaling braking\\\\n\\");\\n        lf_set(brake, 1);\\n      }\\n    } else if (lidar_in->is_present) {\\n      if (lidar_analysis(lidar_in->value)) {\\n        printf(\\"Lidar has detected close object -> signaling braking\\\\n\\");\\n        lf_set(brake, 1);\\n      }\\n    }\\n\\n    self->n_invocs++;\\n    if (self->n_invocs % 2) {\\n      lf_set_fed_maxwait(0);\\n    } else {\\n      lf_set_fed_maxwait(FOREVER);\\n    }\\n  =} tardy {=\\n    printf(\\"STP violation on AEB\\\\n\\");\\n  =} deadline(100ms) {=\\n    printf(\\"AEB deadline violated\\\\n\\");\\n  =}\\n\\n  federated reactor {\\n    lidar = new Lidar()\\n    radar = new Radar()\\n    \\n    @maxwait(forever)\\n    aeb = new AutomaticEmergencyBraking()\\n    \\n    brake = new BrakingSystem()\\n\\n    lidar.lidar_data -> aeb.lidar_in\\n    radar.radar_data -> aeb.radar_in\\n    aeb.brake -> brake.signal\\n  }\\n}\\n```\\n\\nThe `sensor_fusion()` function combines the data and returns `true` if braking is needed.\\nThe `lidar_analysis()` function uses only lidar data to make a (presumably more conservative) decision.\\nThe `n_invocs` integer state variable counts the number of times the reaction of the `AutomaticEmergencyBraking` reactor is invoked. This variable is used to determine how many inputs the reaction expects to see at the next invocation and set the `maxwait` accordingly. Even invocation numbers mean that the next reaction invocation will happen with both sensor inputs present, so `maxwait` is set to `forever`; with odd invocation numbers, the next reaction invocation will see new data from the lidar only, and `maxwait` is then set to 0.\\n\\nClearly, detecting and handling faults would be needed in practical implementation.\\nThis will be the topic of a subsequent blog."},{"id":"deadlines","metadata":{"permalink":"/blog/deadlines","source":"@site/blog/2025-08-23-deadlines.md","title":"Working with Deadlines","description":"SensorProcessorActuator diagram","date":"2025-08-23T00:00:00.000Z","tags":[{"inline":true,"label":"lingua franca","permalink":"/blog/tags/lingua-franca"},{"inline":true,"label":"deadlines","permalink":"/blog/tags/deadlines"},{"inline":true,"label":"real-time","permalink":"/blog/tags/real-time"},{"inline":true,"label":"scheduling","permalink":"/blog/tags/scheduling"}],"readingTime":14.76,"hasTruncateMarker":true,"authors":[{"name":"Edward A. Lee","title":"Professor at UC Berkeley","url":"http://people.eecs.berkeley.edu/~eal/","imageURL":"https://avatars.githubusercontent.com/u/8513334?v=4","key":"eal","page":null},{"name":"Ravi Akella","title":"Sr. Research Engineer, DENSO International America Inc.","url":"https://www.linkedin.com/in/ravicakella/","imageURL":"https://avatars.githubusercontent.com/u/913550?v=4","key":"rcakella","page":null},{"name":"Francesco Paladino","title":"Postdoc, UC Berkeley","url":"https://dblp.org/pid/347/8232.html","imageURL":"https://avatars.githubusercontent.com/u/47446988?v=4","key":"fra-p","page":null},{"name":"Keiichi Bando","title":"Chief Engineer, DENSO Create Inc.","url":"https://github.com/keiichibando","imageURL":"https://avatars.githubusercontent.com/u/149469685?v=4","key":"keiichibando","page":null}],"frontMatter":{"slug":"deadlines","title":"Working with Deadlines","authors":["eal","rcakella","fra-p","keiichibando"],"tags":["lingua franca","deadlines","real-time","scheduling"]},"unlisted":false,"prevItem":{"title":"Decentralized Consistency","permalink":"/blog/decentralized-consistency"},"nextItem":{"title":"The Lingo Package Manager","permalink":"/blog/lingo"}},"content":"![SensorProcessorActuator diagram](../static/img/blog/SensorProcessorActuator.svg)\\n\\n[Deadlines](/docs/writing-reactors/deadlines) in Lingua Franca serve three purposes: they specify real-time requirements, guide scheduling, and provide fault handlers to invoke when real-time requirements are not met.\\nBut they can be subtle to use, and, do not guide scheduling as much as we would like.\\nThis blog outlines the current state of affairs and lays out ongoing work to improve the situation.\\n\\nA deadline specifies that the physical time at which a reaction _starts_ minus the logical time of that reaction (a time difference called the **lag**) should not exceed some threshold. If it does, then the **deadline violation handler** is invoked rather than the regular reaction.\\n\\nDeadlines expose a number of scheduling subtleties because unrelated reactions can cause a deadline violation.\\nMoreover, many users wonder why the deadline refers to the physical time at which a reaction _starts_ rather than the time at which it _ends_.\\nHere, we explain some of the subtleties.\\n\\n{/* truncate */}\\n\\n## Typical Deadline Pattern\\n\\nThe diagram above depicts a typical pattern, where a periodic reaction polls sensor data, a `Processor` reactor processes the data, and an `Actuator` reactor produces some response.\\nAn **end-to-end** deadline is specified as follows (illustrated in the C target):\\n\\n```lf-c\\nreactor Actuator(limit: time = 50 ms) {\\n  input inp:int\\n  reaction(inp) {=\\n    // Regular reaction.\\n    lf_print(\\"Met deadline. Received %d.\\",  inp->value);\\n  =} deadline (limit) {=\\n    // Deadline violation handler.\\n    lf_print(\\"******* Missed deadline! Received %d.\\", inp->value);\\n  =}\\n}\\n```\\n\\nThe deadline shows up in the diagram with a stopwatch symbol.\\n\\nIn this example, because of the timer in the `Sensor` reactor, the logical times of the events, relative to the start time, are 0, 200 ms, 400 ms, etc., for all reactions.\\nIf the `Actuator` reaction is invoked at a relative physical time greater than 50 ms, 250 ms, 450 ms, etc., then the deadline violation handler will be invoked rather than the regular reaction.\\nIt will print \\"******* Missed deadline!\\" rather than \\"Met deadline.\\"\\n\\nThis deadline is an **end-to-end** deadline because it accounts for any overhead in invoking the sensor, processing its data, communicating between reactors, and scheduling reactions.\\nIt does not account for any processing done in the `Actuator` reaction; the intent is that this be a quick driver, not doing a significant amount of processing.\\n\\n### Why does a deadline constrain the start time of a reaction rather than the end time?\\n\\nIn a typical usage, it may not make sense to actuate based on late data, so we don\'t want to execute the regular reaction only to then discover that the deadline was violated.\\nHence, in this usage, specifying a deadline on the completion of the `Actuator` reaction would not make sense.\\n\\nSpecifying a deadline on the completion the `Processor` reaction would also not make sense.\\nUsually, nobody cares when processing completes; we only care when the results have an effect in the real world.\\nIf we specified only a completion-time deadline for the `Processor` reaction, then nothing would constrain when the `Actuator` reaction is invoked.\\n\\n## Specifying a Deadline on Completion Time\\n\\nAlthough the above pattern is typical, it is not uncommon to actually want to specify a deadline on a completion time.\\nFortunately, this can be easily done with the pattern shown below:\\n\\n![CheckDeadline diagram](../static/img/blog/CheckDeadline.svg)\\n\\nThe `Check` reactor may be specified as follows:\\n\\n```lf-c\\nreactor Check(exec = 10 ms, limit: time = 50 ms) {\\n  input inp:int\\n  reaction(inp) {=\\n    lf_sleep(self->exec);\\n    lf_print(\\"Received %d.\\", inp->value);\\n  =}\\n  reaction(inp) {=\\n    lf_print(\\"Met deadline.\\");\\n  =} deadline (limit) {=\\n    lf_print(\\"******* Missed deadline!\\");\\n  =}\\n}\\n```\\nThis reactor has an `exec` parameter that specifies an (approximate) execution time, in this test case realized using `lf_sleep`.\\nIt has a second reaction triggered by the same input that has a deadline given by the `limit` parameter.\\nIf `limit` is enough larger than `exec`, then the deadline will be met.\\nOtherwise, it will be violated.\\n\\nThis pattern works because reactions belonging to the same reactor are not allowed to execute concurrently (because this would create race conditions accessing state variables). They must execute in sequence, in the order in which they are defined. The numbering in the diagram indicates this ordering.\\n\\nWhen an input arrives, both reactions will be triggered.\\nBut because the reactions must execute in the sequence that they are defined, a constraint on the start time of the second reaction is effectively a deadline on the completion time of the first reaction.\\n\\n### What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?\\n\\nIdeally, the LF scheduler would be using an **earliest deadline first** (**EDF**) scheduling policy.\\nUnder an EDF scheduling policy, upon completion of the first reaction, the second reaction will have a priority based on the time remaining until its deadline is violated.\\nUnder EDF, only another reaction that is _also_ at risk of violating its deadline could execute between these two.\\nHowever, LF does not (yet) implement EDF.\\n\\n## Scheduling\\n\\nAs of version 0.10.1, the default schedulers in all targets of LF have significant limitations dealing with deadlines and do not implement EDF scheduling.\\nHere, we explain how scheduling works in version 0.10.1 and then outline research efforts towards achieving EDF scheduling.\\n\\n### Level scheduling\\n\\nThe schedulers all use a **level scheduling** heuristic to ensure that all precedences have been satisfied when a reaction is invoked.\\nAt each tag (logical time and microstep), several reactions may be triggered.\\nIf there are no dependencies between these reactions, and if there is more than one worker thread, then reactions may be invoked in parallel.\\nBut the scheduler has to ensure that precedences are satisfied.\\n\\nA reaction `r1` has precedence over a reaction `r2` if there is a path (without `after` delays) from outputs that `r1` writes to to inputs that `r2` uses.\\nIn addition, if `r1` and `r2` belong to the same reactor, and `r1` is defined before `r2`, then `r1` has precedence.\\nIf `r1` has precedence over `r2`, then `r1` must complete before `r2` can start.\\n\\nFor efficiency, the default schedulers use a conservative approach called \\"level scheduling.\\"\\nAt compile time, the dependencies between reactions are analyzed, and an acyclic precedence graph (APG) is constructed.\\nThe **level** of a reaction `r` is defined as the length of the largest upstream chain of reactions that have precedence over `r`.\\nIf no reaction has precedence over `r`, its level is zero.\\nIf exactly one reaction has precedence over `r`, and that reaction does not depend on other reactions, then `r` has level one. Etc.\\n\\nThe default schedulers all require that all reactions with level _n_ complete before any reaction with level _n_ + 1 can begin.\\nThis constraint can cause unexpected deadline violations.\\n\\nConsider program with the following structure:\\n\\n![ParallelSensorProcessorActuator diagram](../static/img/blog/ParallelSensorProcessorActuator.svg)\\n\\nSuppose that `p1` has an execution time of 60 ms and `p2` has an execution time of 10 ms.\\nThen we might expect the deadline at `a1` to be violated and the deadline at `a2` to be met.\\nBut this is not what happens.\\nThe reactions in `a1` and `a2` both have level 2.\\nBecause of the level scheduling, the reactions in _both_ `p1` and `p2`, which have level 1, must complete before either actuator can be invoked.\\nHence, both deadlines are violated.\\n\\n### Federated Execution\\n\\nOne way to get around the level-scheduling limitation is to make the program federated, splitting it into separate processes, each of which will have its own scheduler, as shown here:\\n\\n![FederatedSensorProcessorActuator diagram](../static/img/blog/FederatedSensorProcessorActuator.svg)\\n\\nHere, `pa1` will consistently miss deadlines (because of the `exec` parameter value of 60 ms), whereas `pa2` will consistently meet the deadline. This structure is defined by the following code:\\n\\n```lf-c\\nimport Sensor, Processor, Actuator from \\"SensorProcessorActuator.lf\\"\\n\\nreactor ProcessorActuator(exec = 10 ms, limit = 50 ms) {\\n  input sensor: int\\n  p = new Processor(exec = exec)\\n  a = new Actuator(limit = limit)\\n  sensor -> p.inp\\n  p.out -> a.inp\\n}\\n\\nfederated reactor {\\n  s = new Sensor()\\n  pa1 = new ProcessorActuator(exec = 60 ms)\\n  pa2 = new ProcessorActuator()\\n  s.out -> pa1.sensor\\n  s.out -> pa2.sensor\\n}\\n```\\n\\nThis can be also be made with two federates rather than three, as shown here:\\n\\n![FederatedSmaller diagram](../static/img/blog/FederatedSmaller.svg)\\n\\nSome care is needed in this case because the code generator inserts a `NetworkSender` reactor, as shown below:\\n\\n![federate__spa diagram](../static/img/blog/federate__spa.svg)\\n\\nThis is a code-generated Lingua Franca file for the `spa` federate alone.\\nIn this case, the reaction in the `NetworkSender` will have the same level as the reaction in the `Processor` and hence may get delayed, causing the deadline to be missed at the `pa` federate.\\n\\n## Early Deadline Violation Detection\\n\\nA deadline violation handler is invoked when a reaction is to be _started_ late.\\nAbove, we explained how to react to a late _completion time_ of a reaction, but the handler is not invoked until the reaction actually completes.\\nWhat if you need to react as soon as you know that the completion time will be late?\\nHere we describe three complementary mechanisms that can react sooner.\\n\\n### Reactions that Monitor Their Execution Time\\n\\nThe [`lf_check_deadline`](https://www.lf-lang.org/reactor-c/group__API.html#gab3a04dd0a1581844829b28686b6b3c53) function in the [reactor API](https://www.lf-lang.org/reactor-c/group__API.html) can be used to write a reaction that monitors its own execution time against a deadline and invokes its deadline violation handler as soon as it detects that the execution time has exceeded the deadline.\\nThis mechanism works when the reaction is _started_ on time, but when we want it to terminate its execution when it cannot _complete_ on time.\\nA nice example of this is given in the [AnytimePrime.lf](https://github.com/lf-lang/playground-lingua-franca/blob/main/examples/C/src/deadlines/AnytimePrime.lf) example in the [deadline collection](https://github.com/lf-lang/playground-lingua-franca/blob/main/examples/C/src/deadlines/README.md) of the [LF playground repo](https://github.com/lf-lang/playground-lingua-franca/tree/main).\\nIt computes as many prime numbers as it can before exceeding a time budget and then aborts.\\n\\n### Federates as Watchdog-Like Monitors\\n\\nThe [decentralized coordinator](https://www.lf-lang.org/docs/next/writing-reactors/distributed-execution#decentralized-coordination) for federated execution gives a convenient mechanism for creating a form of watchdog-like monitor that runs in a separate process or even on a separate machine.\\nThis can give a robust detection of a failure because the monitor can be put on a separate machine from the process being monitored.\\n\\nConsider the following example:\\n\\n![FederatedWatchdog diagram](../static/img/blog/FederatedWatchdog.svg)\\n\\n```lf-c\\ntarget C {\\n  coordination: decentralized\\n}\\nimport Sensor, Processor, Actuator from \\"SensorProcessorActuator.lf\\"\\n\\nreactor Monitored(exec = 10 ms) {\\n  output complete:int\\n  s = new Sensor()\\n  p = new Processor(exec = exec)\\n  a = new Actuator()\\n  s.out -> p.inp\\n  p.out -> a.inp\\n  p.out -> complete\\n}\\n\\nreactor Monitor(STA: time = 50 ms) {\\n  input inp:int\\n  timer t(0, 200 ms)\\n\\n  reaction(t, inp) {=\\n    if (!inp->is_present) {\\n      lf_print(\\"%s: ******* Failed to receive input on time at logical time \\" PRINTF_TIME,\\n          lf_reactor_name(self), lf_time_logical_elapsed());\\n    } else {\\n      lf_print(\\"%s: Monitor OK at logical time \\" PRINTF_TIME,\\n          lf_reactor_name(self), lf_time_logical_elapsed());\\n    }\\n  =} STAA(0) {=\\n    lf_print(\\"%s: ******* Monitor received late input.\\", lf_reactor_name(self));\\n  =}\\n}\\n\\nfederated reactor {\\n  @label(\\"exec = 60 ms\\")\\n  m = new Monitored(exec = 60 ms)\\n  @label(\\"STA = 50 ms\\")\\n  w = new Monitor()\\n  m.complete -> w.inp\\n}\\n```\\n\\nThe `Monitored` reactor is simply a federate containing the sensor-processor-actuator chain.\\nIt is just like above except that it also copies the output of the processor to its own `complete` output.\\n\\nThe `Monitor` federate has a timer that exactly matches the `Sensor` timer in offset and period.\\nThe `Monitor` expects an input from `Monitored` at each tick of this timer.\\nThe [`STA` parameter](https://www.lf-lang.org/docs/next/writing-reactors/distributed-execution#safe-to-advance-sta) (**safe to advance**) specifies that it is safe to advance the federate\'s logical time to the logical time of the timer tick when physical time exceeds that logical time plus the `STA` even if input status is unknown.\\nThe `STA` is set to 50 ms, so, at physical times 50 ms, 250 ms, 450 ms, etc. after the start time, if an input has not arrived, then the input will be assumed to be absent and the `Monitor`\'s reaction will be invoked.\\nThe reaction, therefore, just has to check whether the input is present.\\nIf it is, then the `Monitored` federate is alive and well and its processor output was received by the `Monitor` within 50 ms.\\nOtherwise, something has gone wrong that has led to a delay greater than 50 ms.\\n\\n### Watchdogs\\n\\nAn experimental `watchdog` mechanism is available in LF and is described by\\n[Asch, et al., Software-Defined Watchdog Timers for Cyber-Physical Systems](https://ieeexplore.ieee.org/document/10693560).\\nA `watchdog` specifies a handler that is invoked if, after the watchdog is started using the [`lf_watchdog_start`](https://www.lf-lang.org/reactor-c/group__API.html#ga82bf2c7bd91fdf03b357914cf875dbb9) function in the [reactor API](https://www.lf-lang.org/reactor-c/group__API.html), the watchdog is not stopped or restarted within the specified amount of physical time.\\n\\nA typical usage is to start a watchdog before a potentially problematic reaction is invoked and then stop the watchdog upon completion of the reaction.\\nAs soon as the reaction takes too long to complete, the watchdog handler will be invoked.\\n\\nUsing watchdogs is tricky because the watchdog handler requires a mutual exclusion lock in order to safely access state variables (see [Asch, et al.](https://ieeexplore.ieee.org/document/10693560).\\nFor this reason, federates (or, in the future, enclaves) are preferred.\\n\\n## Ongoing Research\\n\\nSeveral significant efforts are under way to improve the real-time behavior of LF and to guide scheduling using deadlines.\\nSome early work is reported in [Paladino, et al., Layered Scheduling: Toward Better Real-Time Lingua Franca](https://ieeexplore.ieee.org/document/10697337).\\nThat work makes use of an early version of the enclaves mechanism, described below.\\nIt leverages priority-based thread scheduling in the standard Linux kernel.\\nHere, we focus on what is currently available (as of version 0.10.1 and 0.10.2-SNAPSHOT) in LF.\\n\\nThe overarching goal is that reactions with deadlines that are closest to expiring should be given priority and executed as soon as all their precedences have been satisfied.\\nI.e., ideally, LF would implement EDF.\\nBut it does not. Yet.\\nHere, we describe some steps towards achieving such a scheduling policy with LF.\\n\\n### GEDF_NP Scheduler\\n\\nAn early experiment is a scheduler called `GEDF_NP`, which has some initial efforts towards achieving EDF scheduling, although it has many limitations.\\nThis scheduler is specified using a target property as follows:\\n\\n```lf\\ntarget C {\\n  timeout: 1 s,\\n  scheduler: GEDF_NP\\n}\\n```\\n\\nUnlike the default scheduler, this one takes deadlines into account when sorting events on the event queue.\\nConsider the following example:\\n\\n![MoreParallelSensorProcessorActuator diagram](../static/img/blog/MoreParallelSensorProcessorActuator.svg)\\n\\nFor the purposes of sorting events on the event queue, the `GEDF_NP` scheduler propagates deadlines upstream from reactions where they are declared.\\nIn this example, the processors and sensors inherit the deadlines of the actuators that they drive.\\nHence, sensor `s2` will be treated as if it has a deadline of 40 ms, while `s1` will be treated as if it has a deadline of 50 ms.\\n\\nThe timers in each of these sensors have identical periods and offsets, so their events would normally not have any particular ordering.\\nThe `GEDF_NP` scheduler, however, for events with identical tags, gives priority to those with earlier deadlines.\\nIn the above example, it will pull the timer event for `s2` from the event queue and process all reactions that this triggers before pulling the timer event for `s1`.\\nAs a consequence, it overcomes the level-scheduling limitation, and `a2` will meet its deadline.\\n\\nThere are several downsides to this approach, however.\\n\\nFirst, it sacrifices parallelism.\\nIn the above example, suppose that both Processor reactors have an execution time of 30 ms.\\nIn a dual-core (or more) processor, it should be possible to meet both deadlines.\\nHowever, the `GEDF_NP` scheduler processes all the reactions triggered by the timer in `s2` before even fetching the timer event for `s1`.\\nAs a consequence, it will miss the deadline in `a1`.\\nIf the deadlines are made identical, however, both 50 ms, then both deadlines will be met if there are two cores.\\n\\nSecond, the `GEDF_NP` scheduler only considers (inherited) deadlines when sorting the event queue.\\nEvents that do not pass through the event queue are unaffected.\\nAs a consequence, in the following example, both deadlines are missed, even if the deadlines are identical:\\n\\n![ParallelSensorProcessorActuator diagram](../static/img/blog/ParallelSensorProcessorActuator2.svg)\\n\\nAt each tag, there is only one event, the one for the timer in the `s` sensor.\\nThe reaction in `s` will have an inherited deadline of 40 ms (the smaller of the two downstream deadlines), but there is no other competing event with the same tag, so the `GEDF_NP` scheduler will have no effect.\\n\\nThird, the `GEDF_NP` scheduler underperforms the default scheduler by a considerable margin.\\nIt is slower.\\n\\nAs a consequence of these limitations, the `GEDF_NP` scheduler is likely to be retired.\\n\\n### Enclaves\\n\\nAs of version 0.10.2-SNAPSHOT, the development version after the 0.10.1 release, there is some support for **scheduling enclaves**.\\nThese are similar to federates, in that they create separated scheduling domains, but they execute within the same process as their container.\\nSuch an enclave can be created using an `@enclave` annotation, as shown here:\\n\\n```lf-c\\nmain reactor {\\n  ...\\n  @enclave\\n  pa = new ProcessorActuator(exec = 60 ms)\\n  ...\\n}\\n```\\n\\nThe resulting diagram shows a red outline for the enclave:\\n\\n![EnclavedProcessorActuator diagram](../static/img/blog/EnclavedProcessorActuator.svg)\\n\\nIn this case, as with the federate execution, the deadline will be systematically met at actuator `a1` but missed at actuator `pa.a`.\\n\\nAs with federated execution, there is a subtlety because an `EnclaveCommunication` reactor is inserted on the communication path to the enclave.\\nIt has two reactions separated by a logical action, so, for this particular structure, the reaction that sends data to `pa` will have the same level as the reaction in `p1`.\\n\\nEnclaves realize the equivalent of centralized coordination, which makes sense because they all run in the same process.\\nHowever, this means that the `FederatedWatchdog` example cannot be converted as-is to use enclaves.\\nA similar monitor, however, can be created using a physical connection.\\n\\nThe goal of enclaves is to achieve the same decoupling as with federates, but with all enclaves executing in the same process and communicating via shared memory.\\n\\n## Conclusions\\n\\nToday, the deadline mechanism in LF provides a useful mechanism for detecting and reacting to timing anomalies.\\nBut LF does not yet have an effective scheduler that prioritizes reactions with earlier deadlines."},{"id":"lingo","metadata":{"permalink":"/blog/lingo","source":"@site/blog/2023-12-15-release-lingo.md","title":"The Lingo Package Manager","description":"Banner","date":"2023-12-15T00:00:00.000Z","tags":[{"inline":true,"label":"lingo","permalink":"/blog/tags/lingo"},{"inline":true,"label":"lingua franca","permalink":"/blog/tags/lingua-franca"},{"inline":true,"label":"packaging","permalink":"/blog/tags/packaging"},{"inline":true,"label":"build tool","permalink":"/blog/tags/build-tool"}],"readingTime":2.2,"hasTruncateMarker":true,"authors":[{"name":"Tassilo Tanneberger","title":"Student at TUD Dresden University of Technology","url":"https://github.com/tanneberger","imageURL":"https://avatars.githubusercontent.com/u/32239737?v=4","key":"tassilo","page":null},{"name":"Marten Lohstroh","title":"Staff Researcher at UC Berkeley","url":"https://github.com/lhstrh","imageURL":"https://avatars.githubusercontent.com/u/19938940?v=4","key":"lhstrh","page":null}],"frontMatter":{"slug":"lingo","title":"The Lingo Package Manager","authors":["tassilo","lhstrh"],"tags":["lingo","lingua franca","packaging","build tool"]},"unlisted":false,"prevItem":{"title":"Working with Deadlines","permalink":"/blog/deadlines"},"nextItem":{"title":"New Lingua Franca Website","permalink":"/blog/docusaurus"}},"content":"![Banner](../static/img/blog/lingo-release-post.png)\\n\\nProgramming languages like Python, Rust, or JavaScript are popular not only because of particular language features, but also thanks to the quality of the tools and packages they offer access to.\\nA good and mature ecosystem includes features such as developer support, mainly through IDEs or LSPs. Lingua Franca already shines in this area with its VSCode integration that offers functionality like code highlighting, error handling, build support, and diagram synthesis. Another important aspect of a modern language\'s ecosystem concerns package management. Although it is possible to import reactors from files in the local file system, support for packaging in Lingua Franca is still in its infancy.\\n\\n{/* truncate */}\\n\\nThe Lingua Franca team is therefore pleased to present **Lingo**, a new package manager and build tool for Lingua Franca. While we still have a long list of features that we want Lingo to have (including the ability to publish packages), you can already do quite a few useful things with it.\\nFor instance, you can easily set up new Lingua Franca projects with `lingo init --language`, which creates a `Lingo.toml` and a small hello world program under `src/Main.lf`. The `Lingo.toml` specifies a set of apps that are executable LF programs. Apps can be configured with additional build and target properties.\\n\\n```toml\\n[package]\\nname = \\"Showcase\\"\\nversion = \\"0.1.0\\"\\n\\n[properties]\\n\\n[[app]]\\nname = \\"Main\\"\\nmain = \\"./src/Main.lf\\"\\ntarget = \\"Cpp\\"\\nplatform = \\"Native\\"\\n\\n[app.dependencies]\\n\\n[app.properties]\\n```\\n\\nTo build this app, simply run `lingo build` and Lingo will start building all the apps specified in the Lingo.toml. You can then find your build result in `./target/bin/Main` or simply run `lingo run` if you want to execute the result. The command `lingo clean` is available for cleaning up build items.\\n\\nLingo uses an internal concept called backends to wrap the different tool chains of targets. At the moment there is a `CMake` (Cpp), `pnpm`, `npm` (Typescript) and a `lfc` backend, but the `lfc` backend is a temporary solution until a backend is written for all the different toolchains. Therefore, it is important to know that not all targets and functions are officially supported yet. Especially the creation of federated or embedded programs is not yet supported.\\n\\nWe highly encourage the use of Lingo as it already improves the quality of life when developing LF applications and gives us valuable insights into the needs of developers. But you may be wondering how you can get Lingo. Lingo is published on crates.io. To install it, simply run:\\n\\n```\\ncargo install lingua-franca\\n```\\n\\nand `lingo` should show up in your `$PATH`. If you have a question, problem or bug, please submit a issue [here](https://github.com/lf-lang/lingo/issues)."},{"id":"docusaurus","metadata":{"permalink":"/blog/docusaurus","source":"@site/blog/2023-12-11-docusaurus.md","title":"New Lingua Franca Website","description":"We have a new website! Most importantly, this website is the home of our documentation.","date":"2023-12-11T00:00:00.000Z","tags":[{"inline":true,"label":"docusaurus","permalink":"/blog/tags/docusaurus"},{"inline":true,"label":"website","permalink":"/blog/tags/website"},{"inline":true,"label":"lingua franca","permalink":"/blog/tags/lingua-franca"},{"inline":true,"label":"docs","permalink":"/blog/tags/docs"}],"readingTime":1.27,"hasTruncateMarker":true,"authors":[{"name":"axmmisaka","url":"https://github.com/axmmisaka","imageURL":"https://github.com/axmmisaka/axmmisaka/blob/master/nadeshiko_noodle.jpg?raw=true","key":"axmmisaka","page":null},{"name":"Marten Lohstroh","title":"Staff Researcher at UC Berkeley","url":"https://github.com/lhstrh","imageURL":"https://avatars.githubusercontent.com/u/19938940?v=4","key":"lhstrh","page":null}],"frontMatter":{"slug":"docusaurus","title":"New Lingua Franca Website","authors":["axmmisaka","lhstrh"],"tags":["docusaurus","website","lingua franca","docs"]},"unlisted":false,"prevItem":{"title":"The Lingo Package Manager","permalink":"/blog/lingo"}},"content":"We have a new website! Most importantly, this website is the home of our documentation. \\n\\nAfter careful consideration, we realized that our original website had become overly intricate to maintain due to its numerous customizations and dependencies. Writing comprehensive documentation is already a challenging and time-consuming task, and we were keen on avoiding additional complexity that could hinder our progress. Additionally, we had a wishlist of new features, including the ability to version our documentation, incorporate a blog page, and provide support for [MDX](https://mdxjs.com/). In pursuit of solutions, we explored various options.\\n\\n{/* truncate */}\\n\\n![LinguaFrancasaurus](../static/img/blog/lf-and-docusaurus.svg)\\n\\nFortunately, we discovered a framework that encompassed all the features we desired: [Docusaurus](https://docusaurus.io/). The adoption of this framework allowed us to streamline our infrastructure significantly. Remarkably, we were able to retain essential functionalities, such as our [Algolia](https://www.algolia.com)-based search bar and Markdown-based documentation pages, which are now more accessible for reading and editing.\\n\\nDespite initial reservations about the switch, particularly the prospect of rebuilding LF-specific functionalities\u2014such as support for multiple target languages and Lingua Franca syntax highlighting, which demanded a considerable investment of time and effort - we were pleasantly surprised. Docusaurus-native features like Tabs and Tab Groups, coupled with existing third-party libraries like [Shikiji](https://github.com/antfu/shikiji), seamlessly resolved our concerns with minimal adjustments. This not only addressed our specific needs but also considerably eased website maintenance.\\n\\nWe hope that you like the new look and feel! If you have any comments, corrections, or other suggestions for improvement, feel welcome to create an issue [here](https://github.com/lf-lang/lf-lang.github.io/issues) or submit a pull request [here](https://github.com/lf-lang/lf-lang.github.io/pulls)."}]}}')}}]);