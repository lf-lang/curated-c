"use strict";(globalThis.webpackChunkdocusaurus_classic_typescript=globalThis.webpackChunkdocusaurus_classic_typescript||[]).push([[16425],{13034:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=t(74848),a=t(28453);const s={slug:"deadlines",title:"Working with Deadlines",authors:["eal","rcakella","fra-p","keiichibando"],tags:["lingua franca","deadlines","real-time","scheduling"]},r=void 0,o={permalink:"/blog/deadlines",source:"@site/blog/2025-08-23-deadlines.md",title:"Working with Deadlines",description:"SensorProcessorActuator diagram",date:"2025-08-23T00:00:00.000Z",tags:[{inline:!0,label:"lingua franca",permalink:"/blog/tags/lingua-franca"},{inline:!0,label:"deadlines",permalink:"/blog/tags/deadlines"},{inline:!0,label:"real-time",permalink:"/blog/tags/real-time"},{inline:!0,label:"scheduling",permalink:"/blog/tags/scheduling"}],readingTime:14.76,hasTruncateMarker:!0,authors:[{name:"Edward A. Lee",title:"Professor at UC Berkeley",url:"http://people.eecs.berkeley.edu/~eal/",imageURL:"https://avatars.githubusercontent.com/u/8513334?v=4",key:"eal",page:null},{name:"Ravi Akella",title:"Sr. Research Engineer, DENSO International America Inc.",url:"https://www.linkedin.com/in/ravicakella/",imageURL:"https://avatars.githubusercontent.com/u/913550?v=4",key:"rcakella",page:null},{name:"Francesco Paladino",title:"Postdoc, UC Berkeley",url:"https://dblp.org/pid/347/8232.html",imageURL:"https://avatars.githubusercontent.com/u/47446988?v=4",key:"fra-p",page:null},{name:"Keiichi Bando",title:"Chief Engineer, DENSO Create Inc.",url:"https://github.com/keiichibando",imageURL:"https://avatars.githubusercontent.com/u/149469685?v=4",key:"keiichibando",page:null}],frontMatter:{slug:"deadlines",title:"Working with Deadlines",authors:["eal","rcakella","fra-p","keiichibando"],tags:["lingua franca","deadlines","real-time","scheduling"]},unlisted:!1,prevItem:{title:"Decentralized Consistency",permalink:"/blog/decentralized-consistency"},nextItem:{title:"The Lingo Package Manager",permalink:"/blog/lingo"}},c={authorsImageUrls:[void 0,void 0,void 0,void 0]},l=[{value:"Typical Deadline Pattern",id:"typical-deadline-pattern",level:2},{value:"Why does a deadline constrain the start time of a reaction rather than the end time?",id:"why-does-a-deadline-constrain-the-start-time-of-a-reaction-rather-than-the-end-time",level:3},{value:"Specifying a Deadline on Completion Time",id:"specifying-a-deadline-on-completion-time",level:2},{value:"What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?",id:"what-keeps-other-reactions-from-executing-between-the-invocation-of-the-first-reaction-and-the-invocation-of-the-second",level:3},{value:"Scheduling",id:"scheduling",level:2},{value:"Level scheduling",id:"level-scheduling",level:3},{value:"Federated Execution",id:"federated-execution",level:3},{value:"Early Deadline Violation Detection",id:"early-deadline-violation-detection",level:2},{value:"Reactions that Monitor Their Execution Time",id:"reactions-that-monitor-their-execution-time",level:3},{value:"Federates as Watchdog-Like Monitors",id:"federates-as-watchdog-like-monitors",level:3},{value:"Watchdogs",id:"watchdogs",level:3},{value:"Ongoing Research",id:"ongoing-research",level:2},{value:"GEDF_NP Scheduler",id:"gedf_np-scheduler",level:3},{value:"Enclaves",id:"enclaves",level:3},{value:"Conclusions",id:"conclusions",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"SensorProcessorActuator diagram",src:t(81890).A+"",width:"363",height:"114"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/docs/writing-reactors/deadlines",children:"Deadlines"})," in Lingua Franca serve three purposes: they specify real-time requirements, guide scheduling, and provide fault handlers to invoke when real-time requirements are not met.\nBut they can be subtle to use, and, do not guide scheduling as much as we would like.\nThis blog outlines the current state of affairs and lays out ongoing work to improve the situation."]}),"\n",(0,i.jsxs)(n.p,{children:["A deadline specifies that the physical time at which a reaction ",(0,i.jsx)(n.em,{children:"starts"})," minus the logical time of that reaction (a time difference called the ",(0,i.jsx)(n.strong,{children:"lag"}),") should not exceed some threshold. If it does, then the ",(0,i.jsx)(n.strong,{children:"deadline violation handler"})," is invoked rather than the regular reaction."]}),"\n",(0,i.jsxs)(n.p,{children:["Deadlines expose a number of scheduling subtleties because unrelated reactions can cause a deadline violation.\nMoreover, many users wonder why the deadline refers to the physical time at which a reaction ",(0,i.jsx)(n.em,{children:"starts"})," rather than the time at which it ",(0,i.jsx)(n.em,{children:"ends"}),".\nHere, we explain some of the subtleties."]}),"\n","\n",(0,i.jsx)(n.h2,{id:"typical-deadline-pattern",children:"Typical Deadline Pattern"}),"\n",(0,i.jsxs)(n.p,{children:["The diagram above depicts a typical pattern, where a periodic reaction polls sensor data, a ",(0,i.jsx)(n.code,{children:"Processor"})," reactor processes the data, and an ",(0,i.jsx)(n.code,{children:"Actuator"})," reactor produces some response.\nAn ",(0,i.jsx)(n.strong,{children:"end-to-end"})," deadline is specified as follows (illustrated in the C target):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lf-c",children:'reactor Actuator(limit: time = 50 ms) {\n  input inp:int\n  reaction(inp) {=\n    // Regular reaction.\n    lf_print("Met deadline. Received %d.",  inp->value);\n  =} deadline (limit) {=\n    // Deadline violation handler.\n    lf_print("******* Missed deadline! Received %d.", inp->value);\n  =}\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The deadline shows up in the diagram with a stopwatch symbol."}),"\n",(0,i.jsxs)(n.p,{children:["In this example, because of the timer in the ",(0,i.jsx)(n.code,{children:"Sensor"})," reactor, the logical times of the events, relative to the start time, are 0, 200 ms, 400 ms, etc., for all reactions.\nIf the ",(0,i.jsx)(n.code,{children:"Actuator"}),' reaction is invoked at a relative physical time greater than 50 ms, 250 ms, 450 ms, etc., then the deadline violation handler will be invoked rather than the regular reaction.\nIt will print "******* Missed deadline!" rather than "Met deadline."']}),"\n",(0,i.jsxs)(n.p,{children:["This deadline is an ",(0,i.jsx)(n.strong,{children:"end-to-end"})," deadline because it accounts for any overhead in invoking the sensor, processing its data, communicating between reactors, and scheduling reactions.\nIt does not account for any processing done in the ",(0,i.jsx)(n.code,{children:"Actuator"})," reaction; the intent is that this be a quick driver, not doing a significant amount of processing."]}),"\n",(0,i.jsx)(n.h3,{id:"why-does-a-deadline-constrain-the-start-time-of-a-reaction-rather-than-the-end-time",children:"Why does a deadline constrain the start time of a reaction rather than the end time?"}),"\n",(0,i.jsxs)(n.p,{children:["In a typical usage, it may not make sense to actuate based on late data, so we don't want to execute the regular reaction only to then discover that the deadline was violated.\nHence, in this usage, specifying a deadline on the completion of the ",(0,i.jsx)(n.code,{children:"Actuator"})," reaction would not make sense."]}),"\n",(0,i.jsxs)(n.p,{children:["Specifying a deadline on the completion the ",(0,i.jsx)(n.code,{children:"Processor"})," reaction would also not make sense.\nUsually, nobody cares when processing completes; we only care when the results have an effect in the real world.\nIf we specified only a completion-time deadline for the ",(0,i.jsx)(n.code,{children:"Processor"})," reaction, then nothing would constrain when the ",(0,i.jsx)(n.code,{children:"Actuator"})," reaction is invoked."]}),"\n",(0,i.jsx)(n.h2,{id:"specifying-a-deadline-on-completion-time",children:"Specifying a Deadline on Completion Time"}),"\n",(0,i.jsx)(n.p,{children:"Although the above pattern is typical, it is not uncommon to actually want to specify a deadline on a completion time.\nFortunately, this can be easily done with the pattern shown below:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"CheckDeadline diagram",src:t(59201).A+"",width:"278",height:"162"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Check"})," reactor may be specified as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lf-c",children:'reactor Check(exec = 10 ms, limit: time = 50 ms) {\n  input inp:int\n  reaction(inp) {=\n    lf_sleep(self->exec);\n    lf_print("Received %d.", inp->value);\n  =}\n  reaction(inp) {=\n    lf_print("Met deadline.");\n  =} deadline (limit) {=\n    lf_print("******* Missed deadline!");\n  =}\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This reactor has an ",(0,i.jsx)(n.code,{children:"exec"})," parameter that specifies an (approximate) execution time, in this test case realized using ",(0,i.jsx)(n.code,{children:"lf_sleep"}),".\nIt has a second reaction triggered by the same input that has a deadline given by the ",(0,i.jsx)(n.code,{children:"limit"})," parameter.\nIf ",(0,i.jsx)(n.code,{children:"limit"})," is enough larger than ",(0,i.jsx)(n.code,{children:"exec"}),", then the deadline will be met.\nOtherwise, it will be violated."]}),"\n",(0,i.jsx)(n.p,{children:"This pattern works because reactions belonging to the same reactor are not allowed to execute concurrently (because this would create race conditions accessing state variables). They must execute in sequence, in the order in which they are defined. The numbering in the diagram indicates this ordering."}),"\n",(0,i.jsx)(n.p,{children:"When an input arrives, both reactions will be triggered.\nBut because the reactions must execute in the sequence that they are defined, a constraint on the start time of the second reaction is effectively a deadline on the completion time of the first reaction."}),"\n",(0,i.jsx)(n.h3,{id:"what-keeps-other-reactions-from-executing-between-the-invocation-of-the-first-reaction-and-the-invocation-of-the-second",children:"What keeps other reactions from executing between the invocation of the first reaction and the invocation of the second?"}),"\n",(0,i.jsxs)(n.p,{children:["Ideally, the LF scheduler would be using an ",(0,i.jsx)(n.strong,{children:"earliest deadline first"})," (",(0,i.jsx)(n.strong,{children:"EDF"}),") scheduling policy.\nUnder an EDF scheduling policy, upon completion of the first reaction, the second reaction will have a priority based on the time remaining until its deadline is violated.\nUnder EDF, only another reaction that is ",(0,i.jsx)(n.em,{children:"also"})," at risk of violating its deadline could execute between these two.\nHowever, LF does not (yet) implement EDF."]}),"\n",(0,i.jsx)(n.h2,{id:"scheduling",children:"Scheduling"}),"\n",(0,i.jsx)(n.p,{children:"As of version 0.10.1, the default schedulers in all targets of LF have significant limitations dealing with deadlines and do not implement EDF scheduling.\nHere, we explain how scheduling works in version 0.10.1 and then outline research efforts towards achieving EDF scheduling."}),"\n",(0,i.jsx)(n.h3,{id:"level-scheduling",children:"Level scheduling"}),"\n",(0,i.jsxs)(n.p,{children:["The schedulers all use a ",(0,i.jsx)(n.strong,{children:"level scheduling"})," heuristic to ensure that all precedences have been satisfied when a reaction is invoked.\nAt each tag (logical time and microstep), several reactions may be triggered.\nIf there are no dependencies between these reactions, and if there is more than one worker thread, then reactions may be invoked in parallel.\nBut the scheduler has to ensure that precedences are satisfied."]}),"\n",(0,i.jsxs)(n.p,{children:["A reaction ",(0,i.jsx)(n.code,{children:"r1"})," has precedence over a reaction ",(0,i.jsx)(n.code,{children:"r2"})," if there is a path (without ",(0,i.jsx)(n.code,{children:"after"})," delays) from outputs that ",(0,i.jsx)(n.code,{children:"r1"})," writes to to inputs that ",(0,i.jsx)(n.code,{children:"r2"})," uses.\nIn addition, if ",(0,i.jsx)(n.code,{children:"r1"})," and ",(0,i.jsx)(n.code,{children:"r2"})," belong to the same reactor, and ",(0,i.jsx)(n.code,{children:"r1"})," is defined before ",(0,i.jsx)(n.code,{children:"r2"}),", then ",(0,i.jsx)(n.code,{children:"r1"})," has precedence.\nIf ",(0,i.jsx)(n.code,{children:"r1"})," has precedence over ",(0,i.jsx)(n.code,{children:"r2"}),", then ",(0,i.jsx)(n.code,{children:"r1"})," must complete before ",(0,i.jsx)(n.code,{children:"r2"})," can start."]}),"\n",(0,i.jsxs)(n.p,{children:['For efficiency, the default schedulers use a conservative approach called "level scheduling."\nAt compile time, the dependencies between reactions are analyzed, and an acyclic precedence graph (APG) is constructed.\nThe ',(0,i.jsx)(n.strong,{children:"level"})," of a reaction ",(0,i.jsx)(n.code,{children:"r"})," is defined as the length of the largest upstream chain of reactions that have precedence over ",(0,i.jsx)(n.code,{children:"r"}),".\nIf no reaction has precedence over ",(0,i.jsx)(n.code,{children:"r"}),", its level is zero.\nIf exactly one reaction has precedence over ",(0,i.jsx)(n.code,{children:"r"}),", and that reaction does not depend on other reactions, then ",(0,i.jsx)(n.code,{children:"r"})," has level one. Etc."]}),"\n",(0,i.jsxs)(n.p,{children:["The default schedulers all require that all reactions with level ",(0,i.jsx)(n.em,{children:"n"})," complete before any reaction with level ",(0,i.jsx)(n.em,{children:"n"})," + 1 can begin.\nThis constraint can cause unexpected deadline violations."]}),"\n",(0,i.jsx)(n.p,{children:"Consider program with the following structure:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"ParallelSensorProcessorActuator diagram",src:t(51321).A+"",width:"380",height:"212"})}),"\n",(0,i.jsxs)(n.p,{children:["Suppose that ",(0,i.jsx)(n.code,{children:"p1"})," has an execution time of 60 ms and ",(0,i.jsx)(n.code,{children:"p2"})," has an execution time of 10 ms.\nThen we might expect the deadline at ",(0,i.jsx)(n.code,{children:"a1"})," to be violated and the deadline at ",(0,i.jsx)(n.code,{children:"a2"})," to be met.\nBut this is not what happens.\nThe reactions in ",(0,i.jsx)(n.code,{children:"a1"})," and ",(0,i.jsx)(n.code,{children:"a2"})," both have level 2.\nBecause of the level scheduling, the reactions in ",(0,i.jsx)(n.em,{children:"both"})," ",(0,i.jsx)(n.code,{children:"p1"})," and ",(0,i.jsx)(n.code,{children:"p2"}),", which have level 1, must complete before either actuator can be invoked.\nHence, both deadlines are violated."]}),"\n",(0,i.jsx)(n.h3,{id:"federated-execution",children:"Federated Execution"}),"\n",(0,i.jsx)(n.p,{children:"One way to get around the level-scheduling limitation is to make the program federated, splitting it into separate processes, each of which will have its own scheduler, as shown here:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"FederatedSensorProcessorActuator diagram",src:t(71492).A+"",width:"404",height:"326"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"pa1"})," will consistently miss deadlines (because of the ",(0,i.jsx)(n.code,{children:"exec"})," parameter value of 60 ms), whereas ",(0,i.jsx)(n.code,{children:"pa2"})," will consistently meet the deadline. This structure is defined by the following code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lf-c",children:'import Sensor, Processor, Actuator from "SensorProcessorActuator.lf"\n\nreactor ProcessorActuator(exec = 10 ms, limit = 50 ms) {\n  input sensor: int\n  p = new Processor(exec = exec)\n  a = new Actuator(limit = limit)\n  sensor -> p.inp\n  p.out -> a.inp\n}\n\nfederated reactor {\n  s = new Sensor()\n  pa1 = new ProcessorActuator(exec = 60 ms)\n  pa2 = new ProcessorActuator()\n  s.out -> pa1.sensor\n  s.out -> pa2.sensor\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This can be also be made with two federates rather than three, as shown here:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"FederatedSmaller diagram",src:t(65431).A+"",width:"657",height:"238"})}),"\n",(0,i.jsxs)(n.p,{children:["Some care is needed in this case because the code generator inserts a ",(0,i.jsx)(n.code,{children:"NetworkSender"})," reactor, as shown below:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"federate__spa diagram",src:t(67945).A+"",width:"650",height:"224"})}),"\n",(0,i.jsxs)(n.p,{children:["This is a code-generated Lingua Franca file for the ",(0,i.jsx)(n.code,{children:"spa"})," federate alone.\nIn this case, the reaction in the ",(0,i.jsx)(n.code,{children:"NetworkSender"})," will have the same level as the reaction in the ",(0,i.jsx)(n.code,{children:"Processor"})," and hence may get delayed, causing the deadline to be missed at the ",(0,i.jsx)(n.code,{children:"pa"})," federate."]}),"\n",(0,i.jsx)(n.h2,{id:"early-deadline-violation-detection",children:"Early Deadline Violation Detection"}),"\n",(0,i.jsxs)(n.p,{children:["A deadline violation handler is invoked when a reaction is to be ",(0,i.jsx)(n.em,{children:"started"})," late.\nAbove, we explained how to react to a late ",(0,i.jsx)(n.em,{children:"completion time"})," of a reaction, but the handler is not invoked until the reaction actually completes.\nWhat if you need to react as soon as you know that the completion time will be late?\nHere we describe three complementary mechanisms that can react sooner."]}),"\n",(0,i.jsx)(n.h3,{id:"reactions-that-monitor-their-execution-time",children:"Reactions that Monitor Their Execution Time"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://www.lf-lang.org/reactor-c/group__API.html#gab3a04dd0a1581844829b28686b6b3c53",children:(0,i.jsx)(n.code,{children:"lf_check_deadline"})})," function in the ",(0,i.jsx)(n.a,{href:"https://www.lf-lang.org/reactor-c/group__API.html",children:"reactor API"})," can be used to write a reaction that monitors its own execution time against a deadline and invokes its deadline violation handler as soon as it detects that the execution time has exceeded the deadline.\nThis mechanism works when the reaction is ",(0,i.jsx)(n.em,{children:"started"})," on time, but when we want it to terminate its execution when it cannot ",(0,i.jsx)(n.em,{children:"complete"})," on time.\nA nice example of this is given in the ",(0,i.jsx)(n.a,{href:"https://github.com/lf-lang/playground-lingua-franca/blob/main/examples/C/src/deadlines/AnytimePrime.lf",children:"AnytimePrime.lf"})," example in the ",(0,i.jsx)(n.a,{href:"https://github.com/lf-lang/playground-lingua-franca/blob/main/examples/C/src/deadlines/README.md",children:"deadline collection"})," of the ",(0,i.jsx)(n.a,{href:"https://github.com/lf-lang/playground-lingua-franca/tree/main",children:"LF playground repo"}),".\nIt computes as many prime numbers as it can before exceeding a time budget and then aborts."]}),"\n",(0,i.jsx)(n.h3,{id:"federates-as-watchdog-like-monitors",children:"Federates as Watchdog-Like Monitors"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://www.lf-lang.org/docs/next/writing-reactors/distributed-execution#decentralized-coordination",children:"decentralized coordinator"})," for federated execution gives a convenient mechanism for creating a form of watchdog-like monitor that runs in a separate process or even on a separate machine.\nThis can give a robust detection of a failure because the monitor can be put on a separate machine from the process being monitored."]}),"\n",(0,i.jsx)(n.p,{children:"Consider the following example:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"FederatedWatchdog diagram",src:t(48488).A+"",width:"534",height:"202"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lf-c",children:'target C {\n  coordination: decentralized\n}\nimport Sensor, Processor, Actuator from "SensorProcessorActuator.lf"\n\nreactor Monitored(exec = 10 ms) {\n  output complete:int\n  s = new Sensor()\n  p = new Processor(exec = exec)\n  a = new Actuator()\n  s.out -> p.inp\n  p.out -> a.inp\n  p.out -> complete\n}\n\nreactor Monitor(STA: time = 50 ms) {\n  input inp:int\n  timer t(0, 200 ms)\n\n  reaction(t, inp) {=\n    if (!inp->is_present) {\n      lf_print("%s: ******* Failed to receive input on time at logical time " PRINTF_TIME,\n          lf_reactor_name(self), lf_time_logical_elapsed());\n    } else {\n      lf_print("%s: Monitor OK at logical time " PRINTF_TIME,\n          lf_reactor_name(self), lf_time_logical_elapsed());\n    }\n  =} STAA(0) {=\n    lf_print("%s: ******* Monitor received late input.", lf_reactor_name(self));\n  =}\n}\n\nfederated reactor {\n  @label("exec = 60 ms")\n  m = new Monitored(exec = 60 ms)\n  @label("STA = 50 ms")\n  w = new Monitor()\n  m.complete -> w.inp\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Monitored"})," reactor is simply a federate containing the sensor-processor-actuator chain.\nIt is just like above except that it also copies the output of the processor to its own ",(0,i.jsx)(n.code,{children:"complete"})," output."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Monitor"})," federate has a timer that exactly matches the ",(0,i.jsx)(n.code,{children:"Sensor"})," timer in offset and period.\nThe ",(0,i.jsx)(n.code,{children:"Monitor"})," expects an input from ",(0,i.jsx)(n.code,{children:"Monitored"})," at each tick of this timer.\nThe ",(0,i.jsxs)(n.a,{href:"https://www.lf-lang.org/docs/next/writing-reactors/distributed-execution#safe-to-advance-sta",children:[(0,i.jsx)(n.code,{children:"STA"})," parameter"]})," (",(0,i.jsx)(n.strong,{children:"safe to advance"}),") specifies that it is safe to advance the federate's logical time to the logical time of the timer tick when physical time exceeds that logical time plus the ",(0,i.jsx)(n.code,{children:"STA"})," even if input status is unknown.\nThe ",(0,i.jsx)(n.code,{children:"STA"})," is set to 50 ms, so, at physical times 50 ms, 250 ms, 450 ms, etc. after the start time, if an input has not arrived, then the input will be assumed to be absent and the ",(0,i.jsx)(n.code,{children:"Monitor"}),"'s reaction will be invoked.\nThe reaction, therefore, just has to check whether the input is present.\nIf it is, then the ",(0,i.jsx)(n.code,{children:"Monitored"})," federate is alive and well and its processor output was received by the ",(0,i.jsx)(n.code,{children:"Monitor"})," within 50 ms.\nOtherwise, something has gone wrong that has led to a delay greater than 50 ms."]}),"\n",(0,i.jsx)(n.h3,{id:"watchdogs",children:"Watchdogs"}),"\n",(0,i.jsxs)(n.p,{children:["An experimental ",(0,i.jsx)(n.code,{children:"watchdog"})," mechanism is available in LF and is described by\n",(0,i.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/10693560",children:"Asch, et al., Software-Defined Watchdog Timers for Cyber-Physical Systems"}),".\nA ",(0,i.jsx)(n.code,{children:"watchdog"})," specifies a handler that is invoked if, after the watchdog is started using the ",(0,i.jsx)(n.a,{href:"https://www.lf-lang.org/reactor-c/group__API.html#ga82bf2c7bd91fdf03b357914cf875dbb9",children:(0,i.jsx)(n.code,{children:"lf_watchdog_start"})})," function in the ",(0,i.jsx)(n.a,{href:"https://www.lf-lang.org/reactor-c/group__API.html",children:"reactor API"}),", the watchdog is not stopped or restarted within the specified amount of physical time."]}),"\n",(0,i.jsx)(n.p,{children:"A typical usage is to start a watchdog before a potentially problematic reaction is invoked and then stop the watchdog upon completion of the reaction.\nAs soon as the reaction takes too long to complete, the watchdog handler will be invoked."}),"\n",(0,i.jsxs)(n.p,{children:["Using watchdogs is tricky because the watchdog handler requires a mutual exclusion lock in order to safely access state variables (see ",(0,i.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/10693560",children:"Asch, et al."}),".\nFor this reason, federates (or, in the future, enclaves) are preferred."]}),"\n",(0,i.jsx)(n.h2,{id:"ongoing-research",children:"Ongoing Research"}),"\n",(0,i.jsxs)(n.p,{children:["Several significant efforts are under way to improve the real-time behavior of LF and to guide scheduling using deadlines.\nSome early work is reported in ",(0,i.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/10697337",children:"Paladino, et al., Layered Scheduling: Toward Better Real-Time Lingua Franca"}),".\nThat work makes use of an early version of the enclaves mechanism, described below.\nIt leverages priority-based thread scheduling in the standard Linux kernel.\nHere, we focus on what is currently available (as of version 0.10.1 and 0.10.2-SNAPSHOT) in LF."]}),"\n",(0,i.jsx)(n.p,{children:"The overarching goal is that reactions with deadlines that are closest to expiring should be given priority and executed as soon as all their precedences have been satisfied.\nI.e., ideally, LF would implement EDF.\nBut it does not. Yet.\nHere, we describe some steps towards achieving such a scheduling policy with LF."}),"\n",(0,i.jsx)(n.h3,{id:"gedf_np-scheduler",children:"GEDF_NP Scheduler"}),"\n",(0,i.jsxs)(n.p,{children:["An early experiment is a scheduler called ",(0,i.jsx)(n.code,{children:"GEDF_NP"}),", which has some initial efforts towards achieving EDF scheduling, although it has many limitations.\nThis scheduler is specified using a target property as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lf",children:"target C {\n  timeout: 1 s,\n  scheduler: GEDF_NP\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Unlike the default scheduler, this one takes deadlines into account when sorting events on the event queue.\nConsider the following example:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"MoreParallelSensorProcessorActuator diagram",src:t(19624).A+"",width:"379",height:"234"})}),"\n",(0,i.jsxs)(n.p,{children:["For the purposes of sorting events on the event queue, the ",(0,i.jsx)(n.code,{children:"GEDF_NP"})," scheduler propagates deadlines upstream from reactions where they are declared.\nIn this example, the processors and sensors inherit the deadlines of the actuators that they drive.\nHence, sensor ",(0,i.jsx)(n.code,{children:"s2"})," will be treated as if it has a deadline of 40 ms, while ",(0,i.jsx)(n.code,{children:"s1"})," will be treated as if it has a deadline of 50 ms."]}),"\n",(0,i.jsxs)(n.p,{children:["The timers in each of these sensors have identical periods and offsets, so their events would normally not have any particular ordering.\nThe ",(0,i.jsx)(n.code,{children:"GEDF_NP"})," scheduler, however, for events with identical tags, gives priority to those with earlier deadlines.\nIn the above example, it will pull the timer event for ",(0,i.jsx)(n.code,{children:"s2"})," from the event queue and process all reactions that this triggers before pulling the timer event for ",(0,i.jsx)(n.code,{children:"s1"}),".\nAs a consequence, it overcomes the level-scheduling limitation, and ",(0,i.jsx)(n.code,{children:"a2"})," will meet its deadline."]}),"\n",(0,i.jsx)(n.p,{children:"There are several downsides to this approach, however."}),"\n",(0,i.jsxs)(n.p,{children:["First, it sacrifices parallelism.\nIn the above example, suppose that both Processor reactors have an execution time of 30 ms.\nIn a dual-core (or more) processor, it should be possible to meet both deadlines.\nHowever, the ",(0,i.jsx)(n.code,{children:"GEDF_NP"})," scheduler processes all the reactions triggered by the timer in ",(0,i.jsx)(n.code,{children:"s2"})," before even fetching the timer event for ",(0,i.jsx)(n.code,{children:"s1"}),".\nAs a consequence, it will miss the deadline in ",(0,i.jsx)(n.code,{children:"a1"}),".\nIf the deadlines are made identical, however, both 50 ms, then both deadlines will be met if there are two cores."]}),"\n",(0,i.jsxs)(n.p,{children:["Second, the ",(0,i.jsx)(n.code,{children:"GEDF_NP"})," scheduler only considers (inherited) deadlines when sorting the event queue.\nEvents that do not pass through the event queue are unaffected.\nAs a consequence, in the following example, both deadlines are missed, even if the deadlines are identical:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"ParallelSensorProcessorActuator diagram",src:t(51881).A+"",width:"380",height:"212"})}),"\n",(0,i.jsxs)(n.p,{children:["At each tag, there is only one event, the one for the timer in the ",(0,i.jsx)(n.code,{children:"s"})," sensor.\nThe reaction in ",(0,i.jsx)(n.code,{children:"s"})," will have an inherited deadline of 40 ms (the smaller of the two downstream deadlines), but there is no other competing event with the same tag, so the ",(0,i.jsx)(n.code,{children:"GEDF_NP"})," scheduler will have no effect."]}),"\n",(0,i.jsxs)(n.p,{children:["Third, the ",(0,i.jsx)(n.code,{children:"GEDF_NP"})," scheduler underperforms the default scheduler by a considerable margin.\nIt is slower."]}),"\n",(0,i.jsxs)(n.p,{children:["As a consequence of these limitations, the ",(0,i.jsx)(n.code,{children:"GEDF_NP"})," scheduler is likely to be retired."]}),"\n",(0,i.jsx)(n.h3,{id:"enclaves",children:"Enclaves"}),"\n",(0,i.jsxs)(n.p,{children:["As of version 0.10.2-SNAPSHOT, the development version after the 0.10.1 release, there is some support for ",(0,i.jsx)(n.strong,{children:"scheduling enclaves"}),".\nThese are similar to federates, in that they create separated scheduling domains, but they execute within the same process as their container.\nSuch an enclave can be created using an ",(0,i.jsx)(n.code,{children:"@enclave"})," annotation, as shown here:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lf-c",children:"main reactor {\n  ...\n  @enclave\n  pa = new ProcessorActuator(exec = 60 ms)\n  ...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The resulting diagram shows a red outline for the enclave:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"EnclavedProcessorActuator diagram",src:t(64246).A+"",width:"489",height:"247"})}),"\n",(0,i.jsxs)(n.p,{children:["In this case, as with the federate execution, the deadline will be systematically met at actuator ",(0,i.jsx)(n.code,{children:"a1"})," but missed at actuator ",(0,i.jsx)(n.code,{children:"pa.a"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["As with federated execution, there is a subtlety because an ",(0,i.jsx)(n.code,{children:"EnclaveCommunication"})," reactor is inserted on the communication path to the enclave.\nIt has two reactions separated by a logical action, so, for this particular structure, the reaction that sends data to ",(0,i.jsx)(n.code,{children:"pa"})," will have the same level as the reaction in ",(0,i.jsx)(n.code,{children:"p1"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Enclaves realize the equivalent of centralized coordination, which makes sense because they all run in the same process.\nHowever, this means that the ",(0,i.jsx)(n.code,{children:"FederatedWatchdog"})," example cannot be converted as-is to use enclaves.\nA similar monitor, however, can be created using a physical connection."]}),"\n",(0,i.jsx)(n.p,{children:"The goal of enclaves is to achieve the same decoupling as with federates, but with all enclaves executing in the same process and communicating via shared memory."}),"\n",(0,i.jsx)(n.h2,{id:"conclusions",children:"Conclusions"}),"\n",(0,i.jsx)(n.p,{children:"Today, the deadline mechanism in LF provides a useful mechanism for detecting and reacting to timing anomalies.\nBut LF does not yet have an effective scheduler that prioritizes reactions with earlier deadlines."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},19624:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/MoreParallelSensorProcessorActuator-3e799e626be9c646de921253f2d98007.svg"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},48488:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/FederatedWatchdog-eb5871ee989a43e2c5b0d87592a82f18.svg"},51321:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/ParallelSensorProcessorActuator-eaedffcd19a6df0845a907726e0d015f.svg"},51881:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/ParallelSensorProcessorActuator2-c31c8e04487dbef16756335f10d45073.svg"},59201:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/CheckDeadline-f97a3e52d0db8162349f735596399cb9.svg"},64246:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/EnclavedProcessorActuator-a2d784a5bc35ae442795b17fd0c468ad.svg"},65431:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/FederatedSmaller-ee9cda00b2d5ad9dbe7e358e7d0d031e.svg"},67945:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/federate__spa-b0673045f993c172bcca6356067f4479.svg"},71492:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/FederatedSensorProcessorActuator-5b123baf8fe678870d685ce3b4c9bcd5.svg"},81890:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/SensorProcessorActuator-afa90dcb5edb4cdb7f404e307b3a9ef3.svg"}}]);