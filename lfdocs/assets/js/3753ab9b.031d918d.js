"use strict";(globalThis.webpackChunkdocusaurus_classic_typescript=globalThis.webpackChunkdocusaurus_classic_typescript||[]).push([[15041,40969,44737,87063],{10889:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>h,default:()=>f,frontMatter:()=>c,metadata:()=>l,toc:()=>p});var o=n(74848),r=n(28453),s=n(31848),a=n(40969),i=n(15041),d=n(87063);const c={title:"Methods",description:"Methods in Lingua Franca."},h=void 0,l={id:"writing-reactors/methods",title:"Methods",description:"Methods in Lingua Franca.",source:"@site/docs/writing-reactors/methods.mdx",sourceDirName:"writing-reactors",slug:"/writing-reactors/methods",permalink:"/docs/next/writing-reactors/methods",draft:!1,unlisted:!1,editUrl:"https://github.com/lf-lang/lf-lang.github.io/tree/master/docs/writing-reactors/methods.mdx",tags:[],version:"current",frontMatter:{title:"Methods",description:"Methods in Lingua Franca."},sidebar:"handbookSidebar",previous:{title:"Reaction Declarations",permalink:"/docs/next/writing-reactors/reaction-declarations"},next:{title:"Causality Loops",permalink:"/docs/next/writing-reactors/causality-loops"}},m={},p=[{value:"Method Declaration",id:"method-declaration",level:2}];function u(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"method-declaration",children:"Method Declaration"}),"\n",(0,o.jsx)(s.Gv,{c:!0,cpp:!0,py:!0}),"\n",(0,o.jsxs)(s.Sk,{children:[(0,o.jsxs)(s.lr,{c:!0,cpp:!0,children:[(0,o.jsx)(t.p,{children:"Sometimes logic needs to be shared between reactions. In this case, methods can be used to implement the shared logic, and these methods can then be called from reaction bodies. A method declaration has one of the forms:"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lf",children:"  method <name>() {= ... =}\n  method <name>():<type> {= ... =}\n  method <name>(<argument_name>:<type>, ...) {= ... =}\n  method <name>(<argument_name>:<type>, ...):<type> {= ... =}\n"})}),(0,o.jsxs)(t.p,{children:["The first form defines a method with no arguments and no return value. The second form defines a method with the return type ",(0,o.jsx)(t.code,{children:"<type>"})," but no arguments. The third form defines a method with a comma-separated list of arguments given by their name and type, but without a return value. Finally, the fourth form is similar to the third, but adds a return type."]})]}),(0,o.jsxs)(s.lr,{py:!0,children:[(0,o.jsx)(t.p,{children:"A method declaration has the forms:"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lf",children:"  method <name>() {= ... =}\n"})})]})]}),"\n",(0,o.jsx)(s.Ae,{cpp:!0,children:(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"method"})," keyword can optionally be prefixed with the ",(0,o.jsx)(t.code,{children:"const"})," qualifier, which indicates that the method has only read access to the reactor's state."]})}),"\n",(0,o.jsx)(t.p,{children:"Methods are particularly useful in reactors that need to perform certain operations on state variables and/or parameters that are shared between reactions or that are too complex to be implemented in a single reaction. Analogous to class methods, methods in LF can access all state variables and parameters, and can be invoked from all reaction bodies or from other methods. Methods may also recursively invoke themselves. Consider the following example:"}),"\n","\n",(0,o.jsx)(s.UJ,{c:a,cpp:i,py:d,lf:!0}),"\n",(0,o.jsxs)(t.p,{children:["This reactor defines two methods ",(0,o.jsx)(t.code,{children:"getFoo"})," and ",(0,o.jsx)(t.code,{children:"add"}),"."]}),"\n",(0,o.jsx)(s.Ae,{cpp:!0,children:(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"getFoo"})," is qualified as a const method, which indicates that it has read-only\naccess to the state variables. This is directly translated to a C++ const method\nin the code generation process."]})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"getFoo"})," method receives no arguments and returns an integer (",(0,o.jsx)(t.code,{children:"int"}),")\nindicating the current value of the ",(0,o.jsx)(t.code,{children:"foo"})," state variable. The ",(0,o.jsx)(t.code,{children:"add"})," method\nreturns nothing ",(0,o.jsxs)(s.Ae,{c:!0,cpp:!0,inline:!0,children:["(",(0,o.jsx)(t.code,{children:"void"}),")"]})," and receives one integer argument, which it uses to increment ",(0,o.jsx)(t.code,{children:"foo"}),". Both\nmethods are visible in all reactions of the reactor. In this example, the\nreaction to startup calls both methods in order to read and modify its state."]})]})}function f(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},15041:e=>{e.exports="target Cpp\n\nmain reactor Methods {\n  state foo: int(2)\n\n  const method getFoo(): int {=\n    return foo;\n  =}\n\n  method add(x: int) {=\n    foo += x;\n  =}\n\n  reaction(startup) {=\n    std::cout << \"Foo is initialized to \" << getFoo() << '\\n';\n    add(40);\n    std::cout << \"2 + 40 = \" << getFoo() << '\\n';\n  =}\n}\n"},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var o=n(96540);const r={},s=o.createContext(r);function a(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:t},e.children)}},40969:e=>{e.exports='target C\n\nmain reactor Methods {\n  state foo: int = 2\n\n  method getFoo(): int {=\n    return self->foo;\n  =}\n\n  method add(x: int) {=\n    self->foo += x;\n  =}\n\n  reaction(startup) {=\n    lf_print("Foo is initialized to %d", getFoo());\n    add(40);\n    lf_print("2 + 40 = %d", getFoo());\n  =}\n}\n'},87063:e=>{e.exports='target Python\n\nmain reactor Methods {\n  state foo = 2\n\n  method getFoo() {=\n    return self.foo\n  =}\n\n  method add(x) {=\n    self.foo += x\n  =}\n\n  reaction(startup) {=\n    print(f"Foo is initialized to {self.getFoo()}.")\n    self.add(40)\n    print(f"2 + 40 = {self.getFoo()}.")\n  =}\n}\n'}}]);