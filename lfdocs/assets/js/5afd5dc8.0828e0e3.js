"use strict";(globalThis.webpackChunkdocusaurus_classic_typescript=globalThis.webpackChunkdocusaurus_classic_typescript||[]).push([[48737],{7722:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/AutomaticEmergencyBrakingSystem-c4e7a155519baf77598fc57b9f4aae04.svg"},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var i=n(96540);const a={},r=i.createContext(a);function s(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:t},e.children)}},35833:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/AircraftDoor-db4cdc2f3abf2013b63db4d1c7201e83.svg"},49053:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=n(74848),a=n(28453);const r={slug:"decentralized-consistency",title:"Decentralized Consistency",authors:["fra-p","eal","rcakella"],tags:["lingua franca","federation","decentralized","consistency","maxwait"]},s=void 0,o={permalink:"/blog/decentralized-consistency",source:"@site/blog/2025-10-14-decentralized-consistency.md",title:"Decentralized Consistency",description:"The design of distributed applications in Lingua Franca requires care, particularly if the coordination of the federation is decentralized. The intent of this post is to illustrate and handle the challenges arising from designing distributed applications in Lingua Franca, with the help of two realistic use cases.",date:"2025-10-14T00:00:00.000Z",tags:[{inline:!0,label:"lingua franca",permalink:"/blog/tags/lingua-franca"},{inline:!0,label:"federation",permalink:"/blog/tags/federation"},{inline:!0,label:"decentralized",permalink:"/blog/tags/decentralized"},{inline:!0,label:"consistency",permalink:"/blog/tags/consistency"},{inline:!0,label:"maxwait",permalink:"/blog/tags/maxwait"}],readingTime:13.14,hasTruncateMarker:!0,authors:[{name:"Francesco Paladino",title:"Postdoc, UC Berkeley",url:"https://dblp.org/pid/347/8232.html",imageURL:"https://avatars.githubusercontent.com/u/47446988?v=4",key:"fra-p",page:null},{name:"Edward A. Lee",title:"Professor at UC Berkeley",url:"http://people.eecs.berkeley.edu/~eal/",imageURL:"https://avatars.githubusercontent.com/u/8513334?v=4",key:"eal",page:null},{name:"Ravi Akella",title:"Sr. Research Engineer, DENSO International America Inc.",url:"https://www.linkedin.com/in/ravicakella/",imageURL:"https://avatars.githubusercontent.com/u/913550?v=4",key:"rcakella",page:null}],frontMatter:{slug:"decentralized-consistency",title:"Decentralized Consistency",authors:["fra-p","eal","rcakella"],tags:["lingua franca","federation","decentralized","consistency","maxwait"]},unlisted:!1,nextItem:{title:"Working with Deadlines",permalink:"/blog/deadlines"}},c={authorsImageUrls:[void 0,void 0,void 0]},d=[{value:"Indefinite wait for inputs: aircraft door use case",id:"indefinite-wait-for-inputs-aircraft-door-use-case",level:2},{value:"Consistency with decentralized coordination",id:"consistency-with-decentralized-coordination",level:3},{value:"Multirate inputs: automatic emergency braking",id:"multirate-inputs-automatic-emergency-braking",level:2},{value:"Desired system properties",id:"desired-system-properties",level:3},{value:"Consistency challenge",id:"consistency-challenge",level:4},{value:"Availability challenge",id:"availability-challenge",level:4},{value:"Dynamic adjustment of <code>maxwait</code>",id:"dynamic-adjustment-of-maxwait",level:3}];function l(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["The design of ",(0,i.jsx)(t.a,{href:"/docs/writing-reactors/distributed-execution",children:"distributed applications"})," in Lingua Franca requires care, particularly if the coordination of the federation is ",(0,i.jsx)(t.a,{href:"/docs/writing-reactors/distributed-execution#decentralized-coordination",children:"decentralized"}),". The intent of this post is to illustrate and handle the challenges arising from designing distributed applications in Lingua Franca, with the help of two realistic use cases."]}),"\n","\n",(0,i.jsx)(t.h2,{id:"indefinite-wait-for-inputs-aircraft-door-use-case",children:"Indefinite wait for inputs: aircraft door use case"}),"\n",(0,i.jsxs)(t.p,{children:["Aircraft doors on passenger flights are currently managed manually by flight attendants.\nBefore takeoff, the flight attendants ",(0,i.jsx)(t.em,{children:"arm"})," the door; if the door is opened in this state, an evacuation slide is automatically inflated and deployed for emergency evacuation.\nWhen the aircraft is at a gate, before opening the door, the flight attendants ",(0,i.jsx)(t.em,{children:"disarm"})," it to avoid the deployment of the evacuation slide.\nFlight attendants are allowed to disarm the door ",(0,i.jsx)(t.em,{children:"only"})," when they see through the porthole the ramp that will allow the passengers to disembark the aircraft."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"AircraftDoor diagram",src:n(35833).A+"",width:"559",height:"128"})}),"\n",(0,i.jsxs)(t.p,{children:["Consider the above Lingua Franca program that implements a simplified system to remotely open an aircraft door that is in the ",(0,i.jsx)(t.em,{children:"armed"})," state.\nThe door implements two independent remote services, door ",(0,i.jsx)(t.em,{children:"disarming"})," and door ",(0,i.jsx)(t.em,{children:"opening"}),", encoded by two different reactions in the ",(0,i.jsx)(t.code,{children:"Door"})," reactor.\nSuppose the pilot in the cockpit issues a command to open the door.\nWe would also like to automate the disarming of the door using a camera to verify the presence of a ramp. When the camera determines that the ramp is present, it triggers the disarming service. The camera detection is triggered by the door open command issued from the cockpit."]}),"\n",(0,i.jsxs)(t.p,{children:["There are different ways to design and refactor the above system, for example, by removing the direct connection between the ",(0,i.jsx)(t.code,{children:"Cockpit"})," and ",(0,i.jsx)(t.code,{children:"Door"})," reactors. Our design choice is meant to highlight that door ",(0,i.jsx)(t.em,{children:"disarming"})," and ",(0,i.jsx)(t.em,{children:"opening"})," are two different and independent remote services triggered by two different commands issued by two different system actors. Therefore, each actor has an independent connection to the door to request its service."]}),"\n",(0,i.jsxs)(t.p,{children:["The purpose of the system is to open the door in reaction to the command from the cockpit whether or not a ramp is present. If a ramp is present, it is imperative that the door be disarmed ",(0,i.jsx)(t.em,{children:"before"})," being opened. Hence, the door, upon receiving the ",(0,i.jsx)(t.code,{children:"open"})," command from the cockpit, should wait for input from the camera before opening."]}),"\n",(0,i.jsxs)(t.p,{children:["The order in which messages are processed is crucial in this application. When the ",(0,i.jsx)(t.em,{children:"disarm"})," and ",(0,i.jsx)(t.em,{children:"open"})," commands arrive with the same tag, the ",(0,i.jsx)(t.em,{children:"disarm"})," service needs to be invoked before opening the door, otherwise the escape slide will be erroneously deployed.\nLingua Franca guarantees determinism in the execution order of reactions with logically simultaneous inputs, and the order is given by the the order of declaration of the reactions inside the reactor. It is then sufficient to declare the ",(0,i.jsx)(t.code,{children:"disarm"})," reaction ",(0,i.jsx)(t.em,{children:"before"})," the ",(0,i.jsx)(t.code,{children:"open"})," one. The diagram confirms the execution order by labeling the ",(0,i.jsx)(t.code,{children:"disarm"})," reaction with 1 and the ",(0,i.jsx)(t.code,{children:"open"})," reaction with 2."]}),"\n",(0,i.jsxs)(t.p,{children:["The problem is that even though the messages are ",(0,i.jsx)(t.em,{children:"logically"})," simultaneous, they do not arrive at the same ",(0,i.jsx)(t.em,{children:"physical"})," time. In fact, the ",(0,i.jsx)(t.code,{children:"open"})," command from the cockpit is likely to arrive before the clearance from the camera because the camera realizes an expensive computer vision algorithm. The door, consequently, has to wait for both inputs before invoking the ",(0,i.jsx)(t.em,{children:"opening"})," service."]}),"\n",(0,i.jsx)(t.p,{children:"This is an example of an application that cannot safely proceed without assurance on its inputs. The following section explains how to obtain the desired behavior in Lingua Franca using the decentralized coordinator (the centralized coordinator automatically provides the required assurance)."}),"\n",(0,i.jsx)(t.h3,{id:"consistency-with-decentralized-coordination",children:"Consistency with decentralized coordination"}),"\n",(0,i.jsx)(t.p,{children:"The application is implemented as a federated program with decentralized coordination, which means that the advancement of logical time in each single federate is not subject to approval from any centralized entities, but it is done locally based on the input it receives from the other federates and on its local physical clock."}),"\n",(0,i.jsxs)(t.p,{children:["Let us consider the case when the ",(0,i.jsx)(t.code,{children:"Door"})," reactor receives the ",(0,i.jsx)(t.em,{children:"open"})," command from the ",(0,i.jsx)(t.code,{children:"Cockpit"})," reactor, but not yet the ",(0,i.jsx)(t.em,{children:"disarm"})," command from the ",(0,i.jsx)(t.code,{children:"Camera"})," reactor. As previously observed, the ",(0,i.jsx)(t.code,{children:"Door"})," cannot proceed to invoke the ",(0,i.jsx)(t.em,{children:"opening"})," service, because it needs to wait for the ",(0,i.jsx)(t.code,{children:"Camera"})," to send the ",(0,i.jsx)(t.em,{children:"disarm"})," command.\nBut how long should it wait?"]}),"\n",(0,i.jsxs)(t.p,{children:["The decentralized coordinator in\nLingua Franca allows you to customize this waiting time. Each federate can be assigned an attribute called ",(0,i.jsx)(t.a,{href:"/docs/writing-reactors/distributed-execution#safe-to-advance-sta",children:(0,i.jsx)(t.code,{children:"maxwait"})})," that controls how long the federate should wait for inputs from other federates before processing an event, such as an input it has just received.\nMore precisely, ",(0,i.jsx)(t.code,{children:"maxwait"})," is the maximum amount of time a federate waits before advancing its logical time to some value ",(0,i.jsx)(t.em,{children:"t"}),". Specifically, to advance to logical time ",(0,i.jsx)(t.em,{children:"t"}),", the federate waits until either all inputs are known up to an including time ",(0,i.jsx)(t.em,{children:"t"})," or its local physical clock exceeds ",(0,i.jsx)(t.em,{children:"t"})," +",(0,i.jsx)(t.code,{children:"maxwait"}),".\nAn input is known up to an including time ",(0,i.jsx)(t.em,{children:"t"})," if a message with timestamp ",(0,i.jsx)(t.em,{children:"t"})," or greater has been received on that input port.\nAt the expiration of the ",(0,i.jsx)(t.code,{children:"maxwait"}),", the federate assumes that any unresolved ports will not receive any messages with timestamps ",(0,i.jsx)(t.em,{children:"t"})," or earlier.\nIt can then advance its logical time to ",(0,i.jsx)(t.em,{children:"t"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["In our example, we want the door to ",(0,i.jsx)(t.em,{children:"wait indefinitely"})," for both ",(0,i.jsx)(t.em,{children:"disarm"})," and ",(0,i.jsx)(t.em,{children:"open"})," commands to arrive before processing any of them. In Lingua Franca, this is obtained by setting ",(0,i.jsx)(t.code,{children:"maxwait"})," to ",(0,i.jsx)(t.code,{children:"forever"}),". The ",(0,i.jsx)(t.code,{children:"Door"})," reactor cannot safely proceed without assurance about the inputs."]}),"\n",(0,i.jsxs)(t.p,{children:["The implementation of the ",(0,i.jsx)(t.code,{children:"Door"})," reactor and its instantiation are shown below:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lf-c",children:'reactor Door {\n  input open: bool\n  input disarm: bool\n  state isDisarmed: bool = false\n  state isOpen: bool = false\n\n  reaction(disarm) {=\n    if (disarm->value) {\n      self->isDisarmed = true;\n      printf("Door disarmed\\n");\n    } else {\n      self->isDisarmed = false;\n      printf("Door armed\\n");\n    }\n  =} tardy {=\n    printf("STP violation\\n");\n    printf("Intended tag: %lld\\n", disarm->intended_tag);\n    printf("Current tag: %lld\\n", lf_time_logical());\n  =}\n\n  reaction(open) {=\n    if (open->value) {\n      self->open = true;\n      printf("Door open\\n");\n    } else {\n      self->open = false;\n      printf("Door closed\\n");\n    }\n  =} tardy {=\n    printf("STP violation\\n");\n    printf("Intended tag: %lld\\n", disarm->intended_tag);\n    printf("Current tag: %lld\\n", lf_time_logical());\n  =}\n}\n\nfederated reactor {\n  c = new Cockpit()\n  v = new Camera()\n  \n  @maxwait(forever)\n  d = new Door()\n\n  c.open -> d.open\n  c.open -> v.check_ramp\n  v.ramp_present -> d.disarm\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"maxwait"})," attribute is specified at instantiation time within the main reactor. Right before creating the instance of the ",(0,i.jsx)(t.code,{children:"Door"})," reactor for which we want to set the attribute, we use the ",(0,i.jsx)(t.code,{children:"@maxwait"})," annotation that takes as input the ",(0,i.jsx)(t.code,{children:"maxwait"})," value."]}),"\n",(0,i.jsxs)(t.p,{children:["The reactions of the ",(0,i.jsx)(t.code,{children:"Door"})," reactor provide ",(0,i.jsx)(t.a,{href:"/docs/writing-reactors/distributed-execution#safe-to-process-stp-violation-handling",children:"fault handlers"})," that are invoked in case the federate assumed inputs were known up to timestamp ",(0,i.jsx)(t.em,{children:"t"})," and then later received a message with timestamp ",(0,i.jsx)(t.em,{children:"t"})," or less. When ",(0,i.jsx)(t.code,{children:"maxwait"})," is ",(0,i.jsx)(t.code,{children:"forever"}),", these fault handlers should never be invoked."]}),"\n",(0,i.jsxs)(t.p,{children:["For finite values of ",(0,i.jsx)(t.code,{children:"maxwait"}),", it is always possible for messages to get sufficiently delayed that the fault handlers will be invoked.\nWhen they are invoked, the current tag will be greater than the intended tag of the message.\nThis type of fault is called a ",(0,i.jsx)(t.strong,{children:"safe-to-process"})," (",(0,i.jsx)(t.strong,{children:"STP"}),") violation because messages are being handled out of tag order.\nThe intended tag of the input can be accessed as shown in the code above."]}),"\n",(0,i.jsx)(t.h2,{id:"multirate-inputs-automatic-emergency-braking",children:"Multirate inputs: automatic emergency braking"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"AutomaticEmergencyBrakingSystem diagram",src:n(7722).A+"",width:"933",height:"354"})}),"\n",(0,i.jsxs)(t.p,{children:["Consider the above Lingua Franca implementation of an automatic emergency braking system, one of the most critical ADAS systems that modern cars are equipped with.\nThe controller system modeled by the ",(0,i.jsx)(t.code,{children:"AutomaticEmergencyBraking"})," reactor reads data coming from two sensors, a lidar and a radar, and uses both to detect objects or pedestrians that cross the trajectory the car.\nThis is a ",(0,i.jsx)(t.em,{children:"sensor fusion"})," problem, where a diversity of sensors is used to get better reliability.\nWhen one of the two sensors signals the presence of an object at a distance shorter than a configurable threshold, the controller triggers the brake to stop the car and avoid crashing into it."]}),"\n",(0,i.jsxs)(t.p,{children:["The sensors are modeled with their own timer that triggers the generation of data. The clocks of all federates are automatically synchronized by the ",(0,i.jsx)(t.a,{href:"/docs/writing-reactors/distributed-execution#clock-synchronization",children:"clock synchronization algorithm"})," of the Lingua Franca runtime (unless this is disabled).\nTypically, in a real use case of this kind, the clock of sensor devices cannot be controlled by Lingua Franca, but a way to work around this limitation is to resample the data collected by sensors with the timing given by a clock that the runtime can control.\nThe sensor reactors of our application are then modeling this resampling of sensor data so that alignment of data from the two sensors is well defined and sensor fusion becomes possible."]}),"\n",(0,i.jsxs)(t.p,{children:["The lidar sensor has a sampling frequency that is twice that of the radar, as indicated by the timers in the corresponding reactors; the lidar timer has a period of 50ms, while that of the radar 100ms.\nTheir deadline is equal to their period and is enforced using the dedicated ",(0,i.jsx)(t.code,{children:"DeadlineCheck"})," reactors, following the guidelines of how to ",(0,i.jsx)(t.a,{href:"/blog/deadlines",children:"work with deadlines"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The sensor behavior in the application can be simulated for testing purposes in a way that each sensor constantly produces distance values above the threshold (i.e., no objects in the way), and then at a random time it sends a distance value below the threshold, indicating the presence of a close object. When the ",(0,i.jsx)(t.code,{children:"AutomaticEmergencyBraking"})," reactor receives that message, it signals the ",(0,i.jsx)(t.code,{children:"BrakingSystem"})," reactor to brake the car, and the whole system shuts down."]}),"\n",(0,i.jsx)(t.h3,{id:"desired-system-properties",children:"Desired system properties"}),"\n",(0,i.jsx)(t.p,{children:"Availability is a crucial property of this application, because we want the automatic emergency braking system to brake as fast as possible when a close object is detected. Consistency is also necessary, as sensor fusion happens with sensor data produced at the same logical time. Even if this is not implemented in our simplified example, sensor fusion in a more general scenario helps rule out false positives, i.e., cases in which one of the sensors erroneously detects a close object that would induce an unnecessary and dangerous braking. False positives are caused by the weaknesses of the specific sensor. For example, rainy or foggy weather reduces the accuracy of lidar sensors. The key concept is to gather data produced at the same logical time by all sensors and combine them to have a more accurate estimate of possible collisions. Consistency and in-order data processing are then required."}),"\n",(0,i.jsx)(t.h4,{id:"consistency-challenge",children:"Consistency challenge"}),"\n",(0,i.jsxs)(t.p,{children:["The application is once agin implemented as a federated program with decentralized coordination.\nConsistency problems may arise when a federate receives data from two or more federates, as it is the case of the ",(0,i.jsx)(t.code,{children:"AutomaticEmergencyBraking"})," reactor.\nThe controller expects to receive input from both sensors at times 0ms, 100ms, 200ms, etc. Let's consider as an example the case where the remote connection between the controller and the radar has a slightly larger delay than that between the controller and the lidar. The lidar input will then always arrive slightly earlier than the radar one. When the controller receives the lidar input, should it process the data immediately, or should it wait for the radar input to come? Sensor fusion requires consistency: if the controller processes the input from the lidar and then the radar data comes, the control action elaborated upon the arrival of the lidar data does not take into account both sensors, even though it should. Hence, in our use case, the ",(0,i.jsx)(t.code,{children:"AutomaticEmergencyBraking"})," reactor needs to wait for both inputs before processing new data."]}),"\n",(0,i.jsxs)(t.p,{children:["In our application, if we aim to process all incoming data with the same logical time to realize sensor fusion, then we can set ",(0,i.jsx)(t.code,{children:"maxwait = forever"})," to ",(0,i.jsx)(t.em,{children:"wait indefinitely"})," for the radar input before processing the radar.\nNote that this might not be a good choice in this example because if a fault causes one of the sensors to stop sending messages, the ADAS system will stop working.\nHence, in practice, we will probably want a smaller value for ",(0,i.jsx)(t.code,{children:"maxwait"}),", and we will want to add fault detection and mitigation to the application.\nFault handling will be addressed in a later blog. Here we assume no such faults."]}),"\n",(0,i.jsx)(t.h4,{id:"availability-challenge",children:"Availability challenge"}),"\n",(0,i.jsxs)(t.p,{children:["Even without faults, however, setting ",(0,i.jsx)(t.code,{children:"maxwait"})," to ",(0,i.jsx)(t.code,{children:"forever"})," creates problems when only the lidar input is expected (50ms, 150ms, 250ms, etc): the controller cannot process that input until an input from the radar comes, because ",(0,i.jsx)(t.code,{children:"maxwait"})," will never expire. For example, if the single lidar input comes at time 50ms, it has to wait until time 100ms before being processed. If that input was signaling the presence of a close object, the detection would be delayed by 50ms, which may potentially mean crashing into the object. The automatic emergency braking system must be available, otherwise it might not brake in time to avoid collisions.\nThe ideal ",(0,i.jsx)(t.code,{children:"maxwait"})," value for maximum availability in the time instants with only the lidar input is 0, because if a single input is expected, no wait is necessary."]}),"\n",(0,i.jsxs)(t.p,{children:["Summing up, consistency for sensor fusion requires ",(0,i.jsx)(t.code,{children:"maxwait = forever"})," when inputs from both sensors are expected (or some finite value for fault tolerance), while availability calls for ",(0,i.jsx)(t.code,{children:"maxwait = 0"})," when only the lidar input is coming. The two values are at odds, and any value in between would mean sacrificing both properties at the same time."]}),"\n",(0,i.jsxs)(t.h3,{id:"dynamic-adjustment-of-maxwait",children:["Dynamic adjustment of ",(0,i.jsx)(t.code,{children:"maxwait"})]}),"\n",(0,i.jsxs)(t.p,{children:["The knowledge of the timing properties of the application under analysis enables the ",(0,i.jsx)(t.em,{children:"a priori"})," determination of the time instants when both inputs are expected and those when only the lidar has new data available.\nLingua Franca allows to dynamically change the ",(0,i.jsx)(t.code,{children:"maxwait"})," in the reaction body using the ",(0,i.jsx)(t.code,{children:"lf_set_fed_maxwait"})," API, that takes as input parameter the new ",(0,i.jsx)(t.code,{children:"maxwait"})," value to set.\nThis capability of the language permits the automatic emergency braking federate to:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["start with ",(0,i.jsx)(t.code,{children:"maxwait"})," statically set to ",(0,i.jsx)(t.code,{children:"forever"})," (or some finite value for fault tolerance), because at time 0 (startup) both sensors produce data;"]}),"\n",(0,i.jsxs)(t.li,{children:["set ",(0,i.jsx)(t.code,{children:"maxwait"})," to 0 after processing both inputs with the same logical time, because the next data will be sent by the lidar only;"]}),"\n",(0,i.jsxs)(t.li,{children:["set ",(0,i.jsx)(t.code,{children:"maxwait"})," back to ",(0,i.jsx)(t.code,{children:"forever"})," after processing the radar input alone, because the next data will be sent by both sensors."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This dynamic solution guarantees both consistency and availability as long as lidar data arrives within 50 ms.\nThe implementation and the instantiation of the ",(0,i.jsx)(t.code,{children:"AutomaticEmergencyBraking"})," reactor are shown below:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lf-c",children:'reactor AutomaticEmergencyBraking {\n  input lidar_in: float\n  input radar_in: float\n  output brake: int\n  state n_invocs: int = 0\n\n  reaction (lidar_in, radar_in) -> brake {=\n    if (lidar_in->is_present && radar_in->is_present) {\n      if (sensor_fusion(lidar_in->value, radar_in->value) {\n        printf("Sensors detect a close object -> signaling braking\\n");\n        lf_set(brake, 1);\n      }\n    } else if (lidar_in->is_present) {\n      if (lidar_analysis(lidar_in->value)) {\n        printf("Lidar has detected close object -> signaling braking\\n");\n        lf_set(brake, 1);\n      }\n    }\n\n    self->n_invocs++;\n    if (self->n_invocs % 2) {\n      lf_set_fed_maxwait(0);\n    } else {\n      lf_set_fed_maxwait(FOREVER);\n    }\n  =} tardy {=\n    printf("STP violation on AEB\\n");\n  =} deadline(100ms) {=\n    printf("AEB deadline violated\\n");\n  =}\n\n  federated reactor {\n    lidar = new Lidar()\n    radar = new Radar()\n    \n    @maxwait(forever)\n    aeb = new AutomaticEmergencyBraking()\n    \n    brake = new BrakingSystem()\n\n    lidar.lidar_data -> aeb.lidar_in\n    radar.radar_data -> aeb.radar_in\n    aeb.brake -> brake.signal\n  }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"sensor_fusion()"})," function combines the data and returns ",(0,i.jsx)(t.code,{children:"true"})," if braking is needed.\nThe ",(0,i.jsx)(t.code,{children:"lidar_analysis()"})," function uses only lidar data to make a (presumably more conservative) decision.\nThe ",(0,i.jsx)(t.code,{children:"n_invocs"})," integer state variable counts the number of times the reaction of the ",(0,i.jsx)(t.code,{children:"AutomaticEmergencyBraking"})," reactor is invoked. This variable is used to determine how many inputs the reaction expects to see at the next invocation and set the ",(0,i.jsx)(t.code,{children:"maxwait"})," accordingly. Even invocation numbers mean that the next reaction invocation will happen with both sensor inputs present, so ",(0,i.jsx)(t.code,{children:"maxwait"})," is set to ",(0,i.jsx)(t.code,{children:"forever"}),"; with odd invocation numbers, the next reaction invocation will see new data from the lidar only, and ",(0,i.jsx)(t.code,{children:"maxwait"})," is then set to 0."]}),"\n",(0,i.jsx)(t.p,{children:"Clearly, detecting and handling faults would be needed in practical implementation.\nThis will be the topic of a subsequent blog."})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);