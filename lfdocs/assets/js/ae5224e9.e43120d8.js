"use strict";(globalThis.webpackChunkdocusaurus_classic_typescript=globalThis.webpackChunkdocusaurus_classic_typescript||[]).push([[84552],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(96540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}},92457:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var r=t(74848),i=t(28453),a=t(31848);const s={title:"Preambles",description:"Defining preambles in Lingua Franca."},o=void 0,l={id:"writing-reactors/preambles",title:"Preambles",description:"Defining preambles in Lingua Franca.",source:"@site/versioned_docs/version-0.7.0/writing-reactors/preambles.mdx",sourceDirName:"writing-reactors",slug:"/writing-reactors/preambles",permalink:"/docs/0.7.0/writing-reactors/preambles",draft:!1,unlisted:!1,editUrl:"https://github.com/lf-lang/lf-lang.github.io/tree/master/versioned_docs/version-0.7.0/writing-reactors/preambles.mdx",tags:[],version:"0.7.0",frontMatter:{title:"Preambles",description:"Defining preambles in Lingua Franca."},sidebar:"handbookSidebar",previous:{title:"Generic Reactors",permalink:"/docs/0.7.0/writing-reactors/generics"},next:{title:"Distributed Execution",permalink:"/docs/0.7.0/writing-reactors/distributed-execution"}},c={},d=[{value:"Preamble",id:"preamble",level:2},{value:"Using Node Modules",id:"using-node-modules",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.Gv,{c:!0,cpp:!0,py:!0,rs:!0,ts:!0}),"\n",(0,r.jsx)(n.h2,{id:"preamble",children:"Preamble"}),"\n",(0,r.jsxs)(n.p,{children:["Reactions may contain arbitrary target-language code, but often it is convenient for that code to invoke external libraries or to share procedure definitions. For either purpose, a reactor may include a ",(0,r.jsx)(n.code,{children:"preamble"})," section."]}),"\n",(0,r.jsxs)(a.Sk,{children:[(0,r.jsxs)(a.lr,{c:!0,children:[(0,r.jsxs)(n.p,{children:["For example, the following reactor uses the ",(0,r.jsx)(n.code,{children:"math"})," C library for its trigonometric functions:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-c",children:'main reactor {\n  preamble {=\n    #include <math.h>\n  =}\n  reaction(startup) {=\n    printf("The cosine of 1 is %f.\\n", cos(1));\n  =}\n}\n'})}),(0,r.jsx)(n.p,{children:"This will print:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"The cosine of 1 is 0.540302.\n"})}),(0,r.jsxs)(n.p,{children:["By putting the ",(0,r.jsx)(n.code,{children:"#include"})," in the ",(0,r.jsx)(n.code,{children:"preamble"}),", the library becomes available in all reactions of this reactor.\nIf you wish to have the library available in all reactors in the same file, you can provide the ",(0,r.jsx)(n.code,{children:"preamble"})," outside the reactor, as shown here:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-c",children:'preamble {=\n  #include <math.h>\n=}\nreactor Cos {\n  reaction(startup) {=\n    printf("The cosine of 1 is %f.\\n", cos(1));\n  =}\n}\nreactor Sin {\n  reaction(startup) {=\n    printf("The sine of 1 is %f.\\n", sin(1));\n  =}\n}\nmain reactor {\n  c = new Cos()\n  s = new Sin()\n}\n'})}),(0,r.jsxs)(n.p,{children:["You can also use the ",(0,r.jsx)(n.code,{children:"preamble"})," to define functions that are shared across reactions within a reactor, as in this example:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-c",children:'main reactor {\n  preamble {=\n    int add_42(int i) {\n      return i + 42;\n    }\n  =}\n  reaction(startup) {=\n    printf("42 plus 42 is %d.\\n", add_42(42));\n  =}\n  reaction(startup) {=\n    printf("42 plus 1 is %d.\\n", add_42(1));\n  =}\n}\n'})}),(0,r.jsx)(n.p,{children:"Not surprisingly, this will print:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"42 plus 42 is 84.\n42 plus 1 is 43.\n"})}),(0,r.jsx)(n.p,{children:"(The order in which these are printed is arbitrary because the reactions can execute in parallel.)"}),(0,r.jsxs)(n.p,{children:["To share a function across ",(0,r.jsx)(n.em,{children:"reactors"}),", however, is a bit trickier.\nA ",(0,r.jsx)(n.code,{children:"preamble"})," that is put outside the ",(0,r.jsx)(n.code,{children:"reactor"})," definition can only contain\n",(0,r.jsx)(n.em,{children:"declarations"})," not ",(0,r.jsx)(n.em,{children:"definitions"})," of functions or variables.\nThe following code, for example will ",(0,r.jsx)(n.strong,{children:"fail to compile"}),":"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-c",children:'preamble {=\n  int add_42(int i) {\n    return i + 42;\n  }\n=}\nreactor Add_42 {\n  reaction(startup) {=\n    printf("42 plus 42 is %d.\\n", add_42(42));\n  =}\n}\nreactor Add_1 {\n  reaction(startup) {=\n    printf("42 plus 1 is %d.\\n", add_42(1));\n  =}\n}\nmain reactor {\n  a = new Add_42()\n  b = new Add_1()\n}\n'})}),(0,r.jsxs)(n.p,{children:["The compiler will issue a ",(0,r.jsx)(n.strong,{children:"duplicate symbol"})," error because the function definition gets repeated in the separate C files generated for the two reactor classes, ",(0,r.jsx)(n.code,{children:"Add_42"})," and ",(0,r.jsx)(n.code,{children:"Add_1"}),". When the compiled C code gets linked, the linker will find two definitions for the function ",(0,r.jsx)(n.code,{children:"add_42"}),"."]}),(0,r.jsxs)(n.p,{children:["To correct this compile error, the file-level preamble should contain only a ",(0,r.jsx)(n.em,{children:"declaration"}),", not a ",(0,r.jsx)(n.em,{children:"definition"}),", as here:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-c",children:'preamble {=\n  int add_42(int i);\n=}\nreactor Add_42 {\n  reaction(startup) {=\n    printf("42 plus 42 is %d.\\n", add_42(42));\n  =}\n}\nreactor Add_1 {\n  reaction(startup) {=\n    printf("42 plus 1 is %d.\\n", add_42(1));\n  =}\n}\nmain reactor {\n  preamble {=\n    int add_42(int i) {\n      return i + 42;\n    }\n  =}\n  a = new Add_42()\n  b = new Add_1()\n}\n'})}),(0,r.jsxs)(n.p,{children:["The function ",(0,r.jsx)(n.em,{children:"definition"})," here is put into the main reactor, but it can be put in any reactor defined in the file."]}),(0,r.jsxs)(n.p,{children:["Most header files contain only declarations, and hence can be safely included\nusing ",(0,r.jsx)(n.code,{children:"#include"})," in a file-level ",(0,r.jsx)(n.code,{children:"preamble"}),". If you wish to use a header file that includes both declarations and definitions, then you will need to include it within each reactor that uses it."]}),(0,r.jsxs)(n.p,{children:["If you wish to share ",(0,r.jsx)(n.em,{children:"variables"})," across reactors, similar constraints apply.\nNote that sharing variables across reactors is ",(0,r.jsx)(n.strong,{children:"strongly discouraged"})," because it can undermine the determinacy of Lingua Franca, and you may have to implement mutual-exclusion locks to access such variables. But it is occassionaly justfiable, as in the following example:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-c",children:'preamble {=\n  extern const char shared_string[];\n=}\nreactor A {\n  reaction(startup) {=\n    printf("Reactor A says %s.\\n", shared_string);\n  =}\n}\nreactor B {\n  reaction(startup) {=\n    printf("Reactor B says %s.\\n", shared_string);\n  =}\n}\nmain reactor {\n  preamble {=\n    const char shared_string[] = "Hello";\n  =}\n  a = new A()\n  b = new B()\n}\n'})}),(0,r.jsxs)(n.p,{children:["Notice the use of the ",(0,r.jsx)(n.code,{children:"extern"})," keyword in C, which is required because the ",(0,r.jsx)(n.em,{children:"definition"})," of the ",(0,r.jsx)(n.code,{children:"shared_string"})," variable will be in a separate (code-generated) C file, the one for ",(0,r.jsx)(n.code,{children:"main"}),", not the ones for ",(0,r.jsx)(n.code,{children:"A"})," and ",(0,r.jsx)(n.code,{children:"B"}),"."]}),(0,r.jsxs)(n.p,{children:["One subtlety is that if you define symbols that you will use in ",(0,r.jsx)(n.code,{children:"input"}),", ",(0,r.jsx)(n.code,{children:"output"}),", or ",(0,r.jsx)(n.code,{children:"state"})," declarations, then the symbols ",(0,r.jsx)(n.em,{children:"must"})," be defined in a file-level ",(0,r.jsx)(n.code,{children:"preamble"}),".\nSpecifically, the following code will ",(0,r.jsx)(n.strong,{children:"fail to compile"}),":"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-c",children:'main reactor {\n  preamble {=\n    typedef int foo;\n  =}\n  state x:foo = 0\n  reaction(startup) {=\n    lf_print("State is %d", self->x);\n  =}\n}\n'})}),(0,r.jsxs)(n.p,{children:["The compiler will issue an ",(0,r.jsx)(n.strong,{children:"unknown type name"})," error. To correct this, just move the declaration to a file-level ",(0,r.jsx)(n.code,{children:"preamble"}),":"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-c",children:'preamble {=\n  typedef int foo;\n=}\nmain reactor {\n  state x:foo = 0\n  reaction(startup) {=\n    lf_print("State is %d", self->x);\n  =}\n}\n'})})]}),(0,r.jsxs)(a.lr,{cpp:!0,children:[(0,r.jsxs)(n.p,{children:["For example, the following reactor uses the ",(0,r.jsx)(n.code,{children:"charconv"})," header from the c++ standard library to convert a string to an integer:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-cpp",children:'target Cpp;\n\nmain reactor {\n  private preamble {=\n    #include <charconv>\n    #include <string>\n  =}\n\n  timer t;\n  reaction(t) {=\n    std::string raw = "42";\n    std::size_t number;\n\n    auto result = std::from_chars(raw.data(), raw.data() + raw.size(), number);\n    if (result.ec == std::errc::invalid_argument) {\n      std::cerr << "Could not convert.";\n    } else {\n      std::cout << "Converted string: " << raw << " to integer: " << number << std::endl;\n    }\n  =}\n}\n'})}),(0,r.jsx)(n.p,{children:"This will print:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[INFO]  Starting the execution\nConverted string: 42 to integer: 42\n[INFO]  Terminating the execution\n"})}),(0,r.jsx)(n.p,{children:"By putting the #include in the preamble, the library becomes available in all reactions of this reactor. Note the private qualifier before the preamble keyword.\nThis ensures that the preamble is only visible to the reactions defined in this reactor and not to any other reactors. In contrast,\nthe public qualifier ensures that the preamble is also visible to other reactors in files that import the reactor defining the public preamble."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-cpp",children:'reactor Preamble {\n  public preamble {=\n    struct MyStruct {\n      int foo;\n      std::string bar;\n    };\n  =}\n\n  private preamble {=\n    auto add_42(int i) noexcept -> int {\n      return i + 42;\n    }\n  =}\n\n  logical action a:MyStruct;\n\n  reaction(startup) {=\n    a.schedule({add_42(42), "baz"});\n  =}\n\n  reaction(a) {=\n    auto value = *a.get();\n    std::cout << "Received " << value.foo << " and \'" << value.bar << "\'\\n";\n  =}\n}\n'})}),(0,r.jsxs)(n.p,{children:["It defines both a public and a private preamble. The public preamble defines the type MyStruct. This type definition will be visible to all elements of the\nPreamble reactor as well as to all reactors defined in files that import Preamble. The private preamble defines the function ",(0,r.jsx)(n.code,{children:"add_42(int i)"}),".\nThis function will only be usable to reactions within the Preamble reactor."]}),(0,r.jsx)(n.p,{children:"You can think of public and private preambles as the equivalent of header files and source files in C++. In fact, the public preamble will be translated to a\nheader file and the private preamble to a source file. As a rule of thumb, all types that are used in port or action definitions as well as in state variables\nor parameters should be defined in a public preamble. Also, declarations of functions to be shared across reactors should be placed in the public preamble.\nEverything else, like function definitions or types that are used only within reactions, should be placed in a private preamble."}),(0,r.jsxs)(n.p,{children:["Note that preambles can also be specified on the file level. These file level preambles are visible to all reactors within the file.\nAn example of this can be found in ",(0,r.jsx)(n.a,{href:"https://github.com/lf-lang/lingua-franca/blob/master/test/Cpp/src/target/PreambleFile.lf",children:"PreambleFile.lf"}),"."]}),(0,r.jsx)(n.p,{children:"Admittedly, the precise interactions of preambles and imports can become confusing. The preamble mechanism will likely be refined in future revisions."}),(0,r.jsxs)(n.p,{children:["Note that functions defined in the preamble cannot access members such as state variables of the reactor unless they are explicitly passed as arguments.\nIf access to the inner state of a reactor is required, ",(0,r.jsx)(n.a,{href:"/docs/0.7.0/writing-reactors/methods#method-declaration",children:"methods"})," present a viable and easy to use alternative."]})]}),(0,r.jsxs)(a.lr,{py:!0,children:[(0,r.jsxs)(n.p,{children:["For example, the following reactor uses the ",(0,r.jsx)(n.code,{children:"platform"})," module to print the platform information and a defined method to add 42 to an integer:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-py",children:'main reactor Preamble {\n\tpreamble {=\n\t\timport platform\n\t\tdef add_42(self, i):\n\t\t\treturn i + 42\n\t=}\n\ttimer t;\n\treaction(t) {=\n\t\ts = "42"\n\t\ti = int(s)\n\t\tprint("Converted string {:s} to int {:d}.".format(s, i))\n\t\tprint("42 plus 42 is ", self.add_42(42))\n\t\tprint("Your platform is ", self.platform.system())\n\t=}\n}\n'})}),(0,r.jsx)(n.p,{children:"On a Linux machine, this will print:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Converted string 42 to int 42.\n42 plus 42 is 84\nYour platform is Linux\n"})}),(0,r.jsxs)(n.p,{children:["By putting import in the ",(0,r.jsx)(n.code,{children:"preamble"}),", the module becomes available in all reactions of this reactor using the ",(0,r.jsx)(n.code,{children:"self"})," modifier."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," Preambles will be put in the generated Python class for the given reactor, and thus is part of the instance of the reactor. This means that anything you put in the preamble will be specific to a particular reactor instance and cannot be used to share information between different instantiations of the reactor (this is a feature, not a bug, because it helps ensure determinacy). For more information about implementation details of the Python target, see ",(0,r.jsx)(n.a,{href:"/docs/0.7.0/reference/target-language-details",children:"Implementation Details"}),"."]}),(0,r.jsxs)(n.p,{children:["Alternatively, you can define a ",(0,r.jsx)(n.code,{children:"preamble"})," outside any reactor definition. Such a ",(0,r.jsx)(n.code,{children:"preamble"})," can be used for functions such as import or to define a global function. The following example shows importing the ",(0,r.jsx)(n.a,{href:"https://github.com/lf-lang/lingua-franca/blob/master/test/Python/src/include/hello.py",children:"hello"})," module:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-py",children:"target Python {\n  files: include/hello.py\n};\npreamble {=\n  import hello\n=}\n"})}),(0,r.jsxs)(n.p,{children:["Notice the usage of the ",(0,r.jsx)(n.code,{children:"files"})," target property to move the ",(0,r.jsx)(n.code,{children:"hello.py"})," module located in the ",(0,r.jsx)(n.code,{children:"include"})," folder of the test directory into the working directory (located in ",(0,r.jsx)(n.code,{children:"src-gen/NAME"}),")."]}),(0,r.jsxs)(n.p,{children:["For another example, the following program uses the built-in Python ",(0,r.jsx)(n.code,{children:"input()"})," function to get typed input from the user:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-py",children:'target Python\nmain reactor {\n  preamble {=\n    import threading\n    def external(self, a):\n      while (True):\n        from_user = input() # Blocking\n        a.schedule(0, from_user)\n  =}\n  state thread\n  physical action a\n  timer t(2 secs, 2 secs)\n\n  reaction(startup) -> a {=\n    self.thread = self.threading.Thread(target=self.external, args=(a,))\n    self.thread.start()\n    print("Type something.")\n  =}\n\n  reaction(a) {=\n    elapsed_time = lf.time.logical_elapsed()\n    print(f"A time {elapsed_time} nsec after start, received: ", a.value)\n  =}\n\n  reaction(t) {=\n    print("Waiting ...")\n  =}\n}\n'})}),(0,r.jsxs)(n.p,{children:["Within the ",(0,r.jsx)(n.code,{children:"preamble"}),", we specify to import the ",(0,r.jsx)(n.code,{children:"threading"})," Python module and define a function that will be started in a separate thread in the reaction to ",(0,r.jsx)(n.code,{children:"startup"}),". The thread function named ",(0,r.jsx)(n.code,{children:"external"})," blocks when ",(0,r.jsx)(n.code,{children:"input()"})," is called until the user types something and hits the return or enter key. Usually, you do not want a Lingua Franca program to block waiting for input. In the above reactor, a ",(0,r.jsx)(n.code,{children:"timer"})," is used to repeatedly trigger a reaction that reminds the user that it is waiting for input."]})]}),(0,r.jsxs)(a.lr,{ts:!0,children:[(0,r.jsx)(n.p,{children:"For example, the following reactor uses Node's built-in path module to extract the base name from a path:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-ts",children:"target TypeScript;\nmain reactor Preamble {\n  preamble {=\n    import * as path from 'path';\n  =}\n  reaction (startup) {=\n    var filename = path.basename('/Users/Refsnes/demo_path.js');\n    console.log(filename);\n  =}\n}\n"})}),(0,r.jsx)(n.p,{children:"This will print:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"demo_path.js\n"})}),(0,r.jsxs)(n.p,{children:["By putting the ",(0,r.jsx)(n.code,{children:"import"})," in the ",(0,r.jsx)(n.strong,{children:"preamble"}),", the library becomes available in all reactions of this reactor. Oddly, it also becomes available in all subsequently defined reactors in the same file. It's a bit more complicated to ",(0,r.jsx)(n.a,{href:"#using-node-modules",children:"set up Node.js modules from npm"})," that aren't built-in, but the reaction code to ",(0,r.jsx)(n.code,{children:"import"})," them is the same as what you see here."]}),(0,r.jsx)(n.p,{children:"You can also use the preamble to define functions that are shared across reactions and reactors:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lf-ts",children:'main reactor Preamble {\n  preamble {=\n    function add42( i:number) {\n      return i + 42;\n    }\n  =}\n  timer t;\n  reaction(t) {=\n    let s = "42";\n    let radix = 10;\n    let i = parseInt(s, radix);\n    console.log("Converted string " + s + " to number " + i);\n    console.log("42 plus 42 is " + add42(42));\n  =}\n}\n'})}),(0,r.jsx)(n.p,{children:"Not surprisingly, this will print:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Converted string 42 to number 42\n42 plus 42 is 84\n"})}),(0,r.jsx)(n.h3,{id:"using-node-modules",children:"Using Node Modules"}),(0,r.jsxs)(n.p,{children:["Installing Node.js modules for TypeScript reactors with ",(0,r.jsx)(n.code,{children:"npm"})," is essentially the same as installing modules for an ordinary Node.js program. First, write a Lingua Franca program (",(0,r.jsx)(n.code,{children:"Foo.lf"}),") and compile it. It may not type check if if you're ",(0,r.jsx)(n.a,{href:"/docs/0.7.0/writing-reactors/preambles",children:"importing modules in the preamble"})," and you haven't installed the modules yet, but compiling your program will cause the TypeScript code generator to ",(0,r.jsx)(n.a,{href:"/docs/0.7.0/reference/target-language-details",children:"produce a project"})," for your program. There should now be a package.json file in the same directory as your .lf file. Open a terminal and navigate to that directory. You can use the standard ",(0,r.jsx)(n.a,{href:"https://docs.npmjs.com/cli/install",children:(0,r.jsx)(n.code,{children:"npm install"})})," command to install modules for your TypeScript reactors."]}),(0,r.jsx)(n.p,{children:"The important takeaway here is with the package.json file and the compiled JavaScript in the Foo/dist/ directory, you have a standard Node.js program that executes as such. You can modify and debug it just as you would a Node.js program."})]}),(0,r.jsx)(a.lr,{rs:!0,children:(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsxs)(n.p,{children:["FIXME: Add ",(0,r.jsx)(n.code,{children:"preamble"})," example."]})})})]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);