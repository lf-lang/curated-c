"use strict";(globalThis.webpackChunkdocusaurus_classic_typescript=globalThis.webpackChunkdocusaurus_classic_typescript||[]).push([[928],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(96540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},67858:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var i=n(74848),o=n(28453),a=n(31848);n(96540);const s={title:"Modal Reactors",description:"Modal Reactors"},r=void 0,c={id:"writing-reactors/modal-models",title:"Modal Reactors",description:"Modal Reactors",source:"@site/versioned_docs/version-0.6.0/writing-reactors/modal-models.mdx",sourceDirName:"writing-reactors",slug:"/writing-reactors/modal-models",permalink:"/docs/0.6.0/writing-reactors/modal-models",draft:!1,unlisted:!1,editUrl:"https://github.com/lf-lang/lf-lang.github.io/tree/master/versioned_docs/version-0.6.0/writing-reactors/modal-models.mdx",tags:[],version:"0.6.0",frontMatter:{title:"Modal Reactors",description:"Modal Reactors"},sidebar:"handbookSidebar",previous:{title:"Superdense Time",permalink:"/docs/0.6.0/writing-reactors/superdense-time"},next:{title:"Deadlines",permalink:"/docs/0.6.0/writing-reactors/deadlines"}},d={},l=[{value:"Syntax",id:"syntax",level:2},{value:"Execution Semantics",id:"execution-semantics",level:2},{value:"Local Time",id:"local-time",level:3},{value:"Startup and Shutdown",id:"startup-and-shutdown",level:3}];function h(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.Gv,{c:!0,py:!0}),"\n",(0,i.jsxs)(t.p,{children:["The basic idea of ",(0,i.jsx)(t.em,{children:"modal reactors"})," is to partition a reactor into disjoint subsets of reactions (or other components) that are associated with mutually exclusive ",(0,i.jsx)(t.em,{children:"modes"}),".\nIn a modal reactor, only a single mode can be active at a particular logical time instant, meaning that activity in other modes is automatically suspended.\nTransitioning between modes switches the reactor's behavior and provides control over continuing or resetting the previous history of the entered mode."]}),"\n",(0,i.jsx)(t.h2,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsxs)(t.p,{children:["Modes can be defined in any reactor, except federated ones.\nEach mode requires a unique (per reactor) name and can declare contents that are local to this mode.\nThere must be exactly one mode marked as ",(0,i.jsx)(t.code,{children:"initial"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lf",children:"reactor TwoModes {\n  ...\n  initial mode One {\n    ...\n  }\n  mode Two {\n    ...\n  }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"A mode can contain local state variables, timers, actions, reactions, reactor instantiations, and connections.\nWhile modes cannot be nested in modes directly, hierarchical composition is possible through the instantiation of modal reactors.\nThe main exception in allowed contents in modes are port declarations, as these are only possible on reactor level.\nYet, modes share the scope with their reactor and, hence, can access ports, state variables, and parameters of the reactor.\nOnly the contents of other modes are excluded.\nA modal reactor can still have reactions, reactor instantiations, etc., that are not located in modes and will consequently be executed independently from mode activity."}),"\n",(0,i.jsx)(t.p,{children:"Mode transitions are declared within reactions.\nIf a reactor has modes, reactions inside modes are allowed to list them as effects.\nSuch an effect enables the use of the target language API to set the next mode."}),"\n",(0,i.jsxs)(a.Sk,{children:[(0,i.jsx)(a.lr,{c:!0,children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lf-c",children:"reaction(trig) -> Two {=\n  if (trig->value) {\n    lf_set_mode(Two);\n  }\n=}\n"})})}),(0,i.jsx)(a.lr,{py:!0,children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lf-py",children:"reaction(trig) -> Two {=\n  if trig.value:\n    Two.set()\n=}\n"})})})]}),"\n",(0,i.jsxs)(t.p,{children:["You can also specify the type of the transition by adding the modifier ",(0,i.jsx)(t.code,{children:"reset(mode)"})," or ",(0,i.jsx)(t.code,{children:"history(mode)"})," in the effects of the\nreaction signature (i.e., after the ",(0,i.jsx)(t.code,{children:"->"}),"). For example, a history transition to the state ",(0,i.jsx)(t.code,{children:"Two"})," is enabled by listing ",(0,i.jsx)(t.code,{children:"history(Two)"}),"\namong the effects of the reaction. The ",(0,i.jsx)(t.code,{children:"reset"})," variant is implicitly assumed when the mode is listed without modifier."]}),"\n",(0,i.jsx)(t.h2,{id:"execution-semantics",children:"Execution Semantics"}),"\n",(0,i.jsxs)(t.p,{children:["The basic effect of modes is that only parts that are contained in the currently active mode (or outside any mode) are executed at any point in time.\nThis also holds for parts that are nested in multiple ",(0,i.jsx)(t.em,{children:"ancestor modes"})," due to hierarchy; consequently, all those ancestors must be active in order to execute.\nReactions in inactive modes are simply not executed, while all components that model timing behavior, namely timers, scheduled actions, and delayed connections, are subject to a concept of ",(0,i.jsx)(t.em,{children:"local time"}),".\nThat means while a mode is inactive, the progress of time is suspended locally.\nHow the timing components behave when a mode becomes active depends on the transition type.\nA mode can be ",(0,i.jsx)(t.em,{children:"reset"})," upon entry, returning it to its initial state.\nAlternatively, it may be entered preserving its ",(0,i.jsx)(t.em,{children:"history"}),", which only has an actual effect if the mode was active before.\nIn the latter case all timing components will continue their delays or period as if no time had passed during inactivity of the mode.\nThe following section will provide a more detailed explanation of this effect."]}),"\n",(0,i.jsxs)(t.p,{children:["Upon reactor startup, the initial mode of each modal reactor is active, others are inactive.\nIf at a tag ",(0,i.jsx)(t.em,{children:"(t, m)"}),", all reactions of this reactor and all its contents have finished executing, and a new mode was set in a reaction, the current mode will be deactivated and the new one will be activated for future execution.\nThis means no reaction of the newly active mode will execute at tag ",(0,i.jsx)(t.em,{children:"(t, m)"}),"; the earliest possible reaction in the new mode occurs one microstep later, at ",(0,i.jsx)(t.em,{children:"(t, m+1)"}),".\nHence, if the newly active mode has for example a timer that will elapse with an offset of zero, it will trigger at ",(0,i.jsx)(t.em,{children:"(t, m+1)"}),".\nIn case the mode itself does not require an immediate execution in the next microstep, it depends on future events, just as in the normal behavior of LF.\nHence, modes in the same reactor are always mutually exclusive w.r.t. superdense time."]}),"\n",(0,i.jsx)(t.p,{children:"A transition is triggered if a new mode is set in a reaction body.\nAs with setting output ports in reaction, a new mode can be set multiple times in the same or different reactions.\nIn the end, the fixed ordering of reactions determines the last effective value that will be used.\nThe new mode does not have to be a different one; it is possible for a mode to reset itself via a reset transition."}),"\n",(0,i.jsx)(t.p,{children:"In case a mode is entered with the reset behavior:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"all contained modal reactors are reset to their initial mode (recursively),"}),"\n",(0,i.jsx)(t.li,{children:"all contained timers are reset and start again awaiting their initial offset,"}),"\n",(0,i.jsx)(t.li,{children:"all contained state variables that are marked for automatic reset are reset to their initial value,"}),"\n",(0,i.jsxs)(t.li,{children:["any contained reactions triggered by ",(0,i.jsx)(t.code,{children:"reset"})," are executed, and"]}),"\n",(0,i.jsx)(t.li,{children:"all events (actions, timers, delayed connections) that were previously scheduled from within this mode are discarded."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Note that ",(0,i.jsx)(t.em,{children:"contained"})," refers to all contents defined locally in the mode and in local reactor instances (recursively) that are not otherwise enclosed in modes of lower levels."]}),"\n",(0,i.jsxs)(t.p,{children:["Whenever a mode is entered with a reset transition, the subsequent timing behavior is as if the mode was never executed before.\nIf there are state variables that need to be reset or reinitialized, then this can be done in a reaction triggered by ",(0,i.jsx)(t.code,{children:"reset"})," or by marking the state variable for automatic reset (e.g., ",(0,i.jsx)(a.Ae,{c:!0,inline:!0,children:(0,i.jsx)(t.code,{children:"reset state x:int(0)"})}),(0,i.jsx)(a.Ae,{py:!0,inline:!0,children:(0,i.jsx)(t.code,{children:"reset state x(0)"})}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["State variables are not reset automatically to their initial conditions because it is idiomatic for reactors to allocate resources or initialize subsystems (e.g., allocate memory or sockets, register an interrupt, or start a server) in reactions triggered by the ",(0,i.jsx)(t.code,{children:"startup"}),", and to store references to these resources in state variables.\nIf these were to be automatically reset, those references would be lost."]}),"\n",(0,i.jsxs)(t.p,{children:["On the other hand, if a mode has been active prior and is then re-entered via a ",(0,i.jsx)(t.code,{children:"history"})," transition, no reset is performed.\nEvents originating from timers, scheduled actions, and delayed connections are adjusted to reflect a remaining delay equal to the remaining delay recorded at the instant the mode was previously deactivated.\nAs a consequence, a mode has a notion of local time that elapses only when the mode is active."]}),"\n",(0,i.jsx)(t.h3,{id:"local-time",children:"Local Time"}),"\n",(0,i.jsx)(t.p,{children:"From the perspective of timers and actions, time is suspended when a mode is inactive.\nThis also applies to indirectly nested reactors within modes and connections with logical delays, if their source lies within a mode."}),"\n","\n",(0,i.jsx)("local_timeSVG",{title:"Illustration of local time (model): local_time"}),"\n",(0,i.jsx)(t.p,{children:"The above LF model illustrates the different characteristics of local time affecting timers and actions in the presence of the two transition types."}),"\n",(0,i.jsxs)(t.p,{children:["It consists of two modes ",(0,i.jsx)(t.code,{children:"One"})," (the initial mode) and ",(0,i.jsx)(t.code,{children:"Two"}),", both in the ",(0,i.jsx)(t.code,{children:"Modal"})," reactor.\nThe ",(0,i.jsx)(t.code,{children:"next"})," input toggles between these modes and is controlled by a reaction at the top level that is triggered by the timer ",(0,i.jsx)(t.code,{children:"T"}),".\nAfter one second, a mode switch is triggered periodically with a period one second.\nEach mode has a timer ",(0,i.jsx)(t.code,{children:"T1"}),"/",(0,i.jsx)(t.code,{children:"T2"})," that triggers a reaction after an initial offset of 100 msec and then periodically after 750 msec.\nThis reaction then schedules a logical action with a delay of 500 msec (the actual target code does not add an additional delay over the minimum specified).\nThis action triggers the second reaction, which writes to the output ",(0,i.jsx)(t.code,{children:"out"}),".\nThe main difference between the modes is that ",(0,i.jsx)(t.code,{children:"One"})," is entered via a history transition, continuing its behavior, while ",(0,i.jsx)(t.code,{children:"Two"}),' is reset.\n(History behavior is indicated by an "H" on the transition edge because it enters into the entire history of the mode.)']}),"\n","\n",(0,i.jsx)("local_time_traceSVG",{title:"Illustration of local time (trace): local_time_trace"}),"\n",(0,i.jsxs)(t.p,{children:["Above is the execution trace of the first 4 seconds of this program.\nBelow the timeline is the currently active mode and above the timeline are the model elements that are executed at certain points in time, together with indicating triggering and their relation through time.\nFor example, at 100 msec, the initial offset of timer ",(0,i.jsx)(t.code,{children:"T1"})," elapses, which leads to the scheduling of the logical action in this mode.\nThe action triggers the reaction 500 msec later, at 600 msec, and thus causes an output.\nThe timing diagram illustrates the different handling of time between history transitions and reset transitions.\nSpecifically, when mode ",(0,i.jsx)(t.code,{children:"One"})," is re-entered via a history transition, at time 2000 msec, the action triggered by ",(0,i.jsx)(t.code,{children:"T1"})," before, at time 850 msec, resumes.\nIn contrast, when mode ",(0,i.jsx)(t.code,{children:"Two"})," is re-entered via a reset transition, at time 3000 msec, the action triggered by ",(0,i.jsx)(t.code,{children:"T2"})," before, at time 1850 msec, gets discarded."]}),"\n","\n",(0,i.jsx)("local_time_plotSVG",{title:"Illustration of local time (plot): local_time_plot"}),"\n",(0,i.jsxs)(t.p,{children:["The above plot illustrates the relation between global time in the environment and the localized time for each timer in the model.\nSince the top-level reactor ",(0,i.jsx)(t.code,{children:"TimingExample"})," is not enclosed by any mode, its time always corresponds to the global time.\nMode ",(0,i.jsx)(t.code,{children:"One"})," is the initial mode and hence progresses in sync with ",(0,i.jsx)(t.code,{children:"TimingExample"})," for the first second.\nDuring inactivity of mode One the timer is suspended and does not advance in time.\nAt 2000 msec it continues relative to this time.\n",(0,i.jsx)(t.code,{children:"T2"})," only starts advancing when the mode becomes active at 1000 msec.\nThe reentry via reset at 3000 msec causes the local time to be reset to zero."]}),"\n",(0,i.jsx)(t.h3,{id:"startup-and-shutdown",children:"Startup and Shutdown"}),"\n",(0,i.jsxs)(t.p,{children:["A challenge for modal execution is the handling ",(0,i.jsx)(t.code,{children:"startup"})," and ",(0,i.jsx)(t.code,{children:"shutdown"})," behavior.\nThese are commonly used for managing memory for state variables, handling connections to sensors or actuators, or starting/joining external threads.\nIf reactions to these triggers are located inside modes they are subject to a special execution regime."]}),"\n",(0,i.jsxs)(t.p,{children:["First, ",(0,i.jsx)(t.code,{children:"startup"})," reactions are invoked at most once at the first activation of a mode.\nSecond, ",(0,i.jsx)(t.code,{children:"shutdown"})," reactions are executed when the reactor shuts down, ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.em,{children:"irrespective"})})," of mode activity, but only if the enclosing modes have been activated at least once.\nHence, every startup has a corresponding shutdown.\nThird, as mentioned before, the new ",(0,i.jsx)(t.code,{children:"reset"})," trigger for reactions can be used, if a startup behavior should be re-executed if a mode is entered with a reset transition."]}),"\n",(0,i.jsx)(t.p,{children:"Note that this may have unexpected implications:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Startup behavior inside modes may occur during execution and not only at program start."}),"\n",(0,i.jsx)(t.li,{children:"Multiple shutdown reactions may be executed, bypassing mutual exclusion of modes."}),"\n",(0,i.jsxs)(t.li,{children:["Reactors that are designed without consideration of modes and use only ",(0,i.jsx)(t.code,{children:"startup"})," (not ",(0,i.jsx)(t.code,{children:"reset"}),") to trigger an execution chain, may not work in modes and cease to function if re-entered with a reset."]}),"\n"]})]})}function m(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);