"use strict";(globalThis.webpackChunkdocusaurus_classic_typescript=globalThis.webpackChunkdocusaurus_classic_typescript||[]).push([[78541],{22476:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>h});var s=n(74848),i=n(28453),r=n(31848);const a={title:"Termination",description:"Terminating a Lingua Franca execution."},o=void 0,c={id:"writing-reactors/termination",title:"Termination",description:"Terminating a Lingua Franca execution.",source:"@site/versioned_docs/version-0.7.0/writing-reactors/termination.mdx",sourceDirName:"writing-reactors",slug:"/writing-reactors/termination",permalink:"/docs/0.7.0/writing-reactors/termination",draft:!1,unlisted:!1,editUrl:"https://github.com/lf-lang/lf-lang.github.io/tree/master/versioned_docs/version-0.7.0/writing-reactors/termination.mdx",tags:[],version:"0.7.0",frontMatter:{title:"Termination",description:"Terminating a Lingua Franca execution."},sidebar:"handbookSidebar",previous:{title:"Distributed Execution",permalink:"/docs/0.7.0/writing-reactors/distributed-execution"},next:{title:"VS Code Extension",permalink:"/docs/0.7.0/tools/code-extension"}},l={},h=[{value:"Shutdown Reactions",id:"shutdown-reactions",level:2},{value:"Timeout",id:"timeout",level:2},{value:"Starvation",id:"starvation",level:2},{value:"Stop Request",id:"stop-request",level:2},{value:"External Signal",id:"external-signal",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.Gv,{c:!0,cpp:!0,py:!0,rs:!0,ts:!0}),"\n",(0,s.jsx)(t.h2,{id:"shutdown-reactions",children:"Shutdown Reactions"}),"\n",(0,s.jsxs)(t.p,{children:["There are several mechanisms for terminating a Lingua Franca in an orderly fashion.\nAll of these mechanisms result in a ",(0,s.jsx)(t.strong,{children:"final tag"})," at which any reaction that declares ",(0,s.jsx)(t.code,{children:"shutdown"})," as a trigger will be invoked (recall that a ",(0,s.jsx)(t.strong,{children:"tag"})," is a tuple (",(0,s.jsx)(t.strong,{children:"logical time"}),", ",(0,s.jsx)(t.strong,{children:"microstep"}),")). Other reactions may also be invoked at this final tag, and the order in which reactions are invoked will be constrained by the normal precedence rules."]}),"\n",(0,s.jsxs)(t.p,{children:["If a reaction triggered by ",(0,s.jsx)(t.code,{children:"shutdown"})," produces outputs, then downstream reactors will also be invoked at the final tag. If the reaction schedules any actions by calling ",(0,s.jsx)(t.code,{children:"schedule()"}),", those will be ignored. In fact, any event after the final tag will be ignored. After the completion of the final tag, the program will exit."]}),"\n",(0,s.jsx)(t.p,{children:"There are four ways to terminate a program:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Timeout"}),": The program specifies the last logical time at which reactions should be triggered."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Starvation"}),": At the conclusion of some tag, there are no events in the event queue at future tags."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Stop request"}),": Some reaction requests that the program terminate."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"External signal"}),": Program is terminated externally using operating services like control-C or ",(0,s.jsx)(t.code,{children:"kill"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"We address each of these in turn."}),"\n",(0,s.jsx)(t.h2,{id:"timeout",children:"Timeout"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsxs)(t.a,{href:"/docs/0.7.0/reference/target-declaration#timeout",children:["target property ",(0,s.jsx)(t.code,{children:"timeout"})]})," specifies the last logical time at which reactions should be triggered. The last invocation of reactions will be at tag (",(0,s.jsx)(t.code,{children:"timeout"}),", 0)."]}),"\n",(0,s.jsxs)(t.p,{children:["There is a significant subtlety when using ",(0,s.jsx)(t.a,{href:"/docs/0.7.0/writing-reactors/composing-reactors#physical-connections",children:"physical connections"}),", which are connections using the syntax ",(0,s.jsx)(t.code,{children:"~>"}),". Such connections specify that the tag at the receiving end will be based on the physical time at which the message is received. If the tag assigned at the receiving end is greater than the final tag, then the message is lost. Hence, ",(0,s.jsxs)(t.strong,{children:["messages sent near the ",(0,s.jsx)(t.code,{children:"timeout"})," time are likely to be lost!"]})]}),"\n",(0,s.jsx)(t.h2,{id:"starvation",children:"Starvation"}),"\n",(0,s.jsxs)(t.p,{children:["If a Lingua Franca program has no ",(0,s.jsx)(t.a,{href:"/docs/0.7.0/writing-reactors/actions#physical-actions",children:"physical actions"}),", and if at any time during execution there are no future events waiting to be processed, then there is no possibility for any more reactions to occur and the program will exit. This situation is called ",(0,s.jsx)(t.strong,{children:"starvation"}),". If there is a ",(0,s.jsx)(t.strong,{children:"timer"})," anywhere in the program with a period, then this condition never occurs."]}),"\n",(0,s.jsxs)(t.p,{children:["One subtlety is that reactions triggered by ",(0,s.jsx)(t.code,{children:"shutdown"})," will be invoked one microstep later than the last tag at which there was an event. They cannot be invoked at the same tag because it is only after that last tag has completed that the runtime system can be sure that there are no future events. It would not be correct to trigger the ",(0,s.jsx)(t.code,{children:"shutdown"})," reactions at that point because it would be impossible to respect the required reaction ordering."]}),"\n",(0,s.jsx)(r.Ae,{c:!0,py:!0,ts:!0,children:(0,s.jsx)(t.p,{children:"Starvation termination is not currently implemented for federated execution. You will need to use one of the other mechanisms to terminate a federated program."})}),"\n",(0,s.jsx)(t.h2,{id:"stop-request",children:"Stop Request"}),"\n",(0,s.jsxs)(t.p,{children:["If a reaction calls the built-in ",(0,s.jsx)(t.code,{children:"lf_request_stop()"})," function, then it is requesting that the program cease execution as soon as possible. This cessation will normally occur in the next microstep. The current tag will be completed as normal. Then the tag will be advanced by one microstep, and reactions triggered by ",(0,s.jsx)(t.code,{children:"shutdown"})," will be executed, along with any other reactions with triggers at that tag, with all reactions executed in precedence order."]}),"\n",(0,s.jsxs)(r.Ae,{c:!0,py:!0,ts:!0,children:[(0,s.jsx)(t.p,{children:"In a federated execution, things are more complicated. In general, it is not possible to cease execution in the next microstep because this would mean that every federate has a communication channel to every other with delay equal to one microstep. This does not create a causality loop, but it means that all federates have to advance time in lockstep, which creates a global barrier synchronization that would likely kill performance. It would also make decentralized coordination impossible because the safe-to-process (STP) threshold for all federates would diverge to infinity."}),(0,s.jsxs)(t.p,{children:["For ",(0,s.jsx)(t.strong,{children:"centralized coordination"}),", when a reaction in a federate calls ",(0,s.jsx)(t.code,{children:"lf_request_stop()"}),", the federate sends a ",(0,s.jsx)(t.strong,{children:"STOP_REQUEST"})," message to the RTI with its current timestamp ",(0,s.jsx)(t.em,{children:"t"})," as a payload and completes execution of any other reactions triggered at the current tag. It then blocks, waiting for a ",(0,s.jsx)(t.strong,{children:"STOP_GRANTED"})," message with a timestamp payload ",(0,s.jsx)(t.em,{children:"s"}),". If ",(0,s.jsx)(t.em,{children:"s"})," > ",(0,s.jsx)(t.em,{children:"t"}),", then it sets ",(0,s.jsx)(t.code,{children:"timeout"})," = ",(0,s.jsx)(t.em,{children:"s"})," and continues executing, using the timeout mechanism (see above) to stop. If ",(0,s.jsx)(t.em,{children:"s"})," = ",(0,s.jsx)(t.em,{children:"t"}),", then schedules the shutdown phase to occur one microstep later, as in the unfederated case."]}),(0,s.jsxs)(t.p,{children:["When the RTI receives a ",(0,s.jsx)(t.strong,{children:"STOP_REQUEST"})," message from a federate, it forwards it to all other federates and waits for a reply from all. Each reply will have a timestamp payload. The RTI chooses ",(0,s.jsx)(t.em,{children:"s"}),", the largest of these timestamps, and sends a ",(0,s.jsx)(t.strong,{children:"STOP_GRANTED"})," message to all federates with payload ",(0,s.jsx)(t.em,{children:"s"}),"."]}),(0,s.jsxs)(t.p,{children:["When a federate receives a ",(0,s.jsx)(t.strong,{children:"STOP_REQUEST"})," message, it replies with its current logical time ",(0,s.jsx)(t.em,{children:"t"}),", completes its current tag (if one is progress), and blocks, waiting for a ",(0,s.jsx)(t.strong,{children:"STOP_GRANTED"})," message from the RTI. When it gets the reply with payload ",(0,s.jsx)(t.em,{children:"s"}),", if ",(0,s.jsx)(t.em,{children:"s"})," > ",(0,s.jsx)(t.em,{children:"t"}),", then it sets ",(0,s.jsx)(t.code,{children:"timeout"})," = ",(0,s.jsx)(t.em,{children:"s"})," and continues executing, using the timeout mechanism (see above) to stop. If ",(0,s.jsx)(t.em,{children:"s"})," = ",(0,s.jsx)(t.em,{children:"t"}),", then it schedules the shutdown phase to occur one microstep later, as in the unfederated case."]})]}),"\n",(0,s.jsx)(t.h2,{id:"external-signal",children:"External Signal"}),"\n",(0,s.jsx)(t.p,{children:"A control-C or other kill signal to a running Lingua Franca program will cause execution to stop immediately."}),"\n",(0,s.jsxs)(r.Ae,{c:!0,py:!0,ts:!0,children:[(0,s.jsx)(t.p,{children:"For federated programs, each federate and the RTI catches external signals to shut down in an orderly way."}),(0,s.jsxs)(t.p,{children:["When a federate gets such an external signal (e.g. control-C), it sends a ",(0,s.jsx)(t.strong,{children:"RESIGN"})," message to the RTI and an ",(0,s.jsx)(t.strong,{children:"EOF"})," (end of file) on each socket connection to another federate. It then closes all sockets and shuts down. The RTI and all other federates should continue running until some other termination condition occurs."]}),(0,s.jsxs)(t.p,{children:["When the RTI gets such an external signal (e.g. control-C), it broadcasts a ",(0,s.jsx)(t.strong,{children:"STOP_REQUEST"})," message to all federates, waits for their replies (with a timeout in case the federate or the network has failed), chooses the maximum timestamp ",(0,s.jsx)(t.em,{children:"s"})," on the replies, broadcasts a ",(0,s.jsx)(t.strong,{children:"STOP_GRANTED"})," message to all federates with payload ",(0,s.jsx)(t.em,{children:"s"}),", and waits for ",(0,s.jsx)(t.strong,{children:"LOGICAL_TIME_COMPLETE"})," messages as above."]})]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);