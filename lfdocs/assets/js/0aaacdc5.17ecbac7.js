"use strict";(globalThis.webpackChunkdocusaurus_classic_typescript=globalThis.webpackChunkdocusaurus_classic_typescript||[]).push([[94401],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var a=n(96540);const r={},s=a.createContext(r);function i(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:t},e.children)}},67699:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>y,contentTitle:()=>j,default:()=>w,frontMatter:()=>f,metadata:()=>g,toc:()=>v});var a=n(74848),r=n(28453),s=n(31848);const i="target C\n\nreactor Scale(factor: int = 2) {\n  input x: int\n  output y: int\n\n  reaction(x) -> y {=\n    lf_set(y, x->value * self->factor);\n  =}\n}\n",c="target Cpp\n\nreactor Scale(factor: int(2)) {\n  input x: int\n  output y: int\n\n  reaction(x) -> y {=\n    y.set(factor * *x.get());\n  =}\n}\n",l="target Python\n\nreactor Scale(factor=2) {\n  input x\n  output y\n\n  reaction(x) -> y {=\n    y.set(x.value * self.factor)\n  =}\n}\n",o="target Rust\n\nreactor Scale(factor: u32 = 2) {\n  state factor = factor\n  input x: u32\n  output y: u32\n\n  reaction(x) -> y {=\n    let x = ctx.get(x).unwrap();\n    ctx.set(y, x * self.factor);\n  =}\n}\n",d="target TypeScript\n\nreactor Scale(factor: number = 2) {\n  input x: number\n  output y: number\n\n  reaction(x) -> y {=\n    if (x !== undefined) y = x * factor\n  =}\n}\n",h="target C\n\nreactor Count {\n  state count: int = 0\n  output y: int\n  timer t(0, 100 msec)\n\n  reaction(t) -> y {=\n    lf_set(y, self->count++);\n  =}\n}\n",p="target Cpp\n\nreactor Count {\n  state count: int(0)\n  output y: int\n  timer t(0, 100 ms)\n\n  reaction(t) -> y {=\n    y.set(count++);\n  =}\n}\n",u="target Python\n\nreactor Count {\n  state count = 0\n  output y\n  timer t(0, 100 msec)\n\n  reaction(t) -> y {=\n    y.set(self.count)\n    self.count += 1\n  =}\n}\n",x="target Rust\n\nreactor Count {\n  state count: u32 = 0\n  output y: u32\n  timer t(0, 100 msec)\n\n  reaction(t) -> y {=\n    ctx.set(y, self.count);\n    self.count += 1;\n  =}\n}\n",m="target TypeScript\n\nreactor Count {\n  state count: number = 0\n  output y: number\n  timer t(0, 100 msec)\n\n  reaction(t) -> y {=\n    y = count++\n  =}\n}\n",f={title:"Parameters and State Variables",description:"Parameters and state variables in Lingua Franca."},j=void 0,g={id:"writing-reactors/parameters-and-state-variables",title:"Parameters and State Variables",description:"Parameters and state variables in Lingua Franca.",source:"@site/versioned_docs/version-0.5.0/writing-reactors/parameters-and-state-variables.mdx",sourceDirName:"writing-reactors",slug:"/writing-reactors/parameters-and-state-variables",permalink:"/docs/0.5.0/writing-reactors/parameters-and-state-variables",draft:!1,unlisted:!1,editUrl:"https://github.com/lf-lang/lf-lang.github.io/tree/master/versioned_docs/version-0.5.0/writing-reactors/parameters-and-state-variables.mdx",tags:[],version:"0.5.0",frontMatter:{title:"Parameters and State Variables",description:"Parameters and state variables in Lingua Franca."},sidebar:"handbookSidebar",previous:{title:"Inputs and Outputs",permalink:"/docs/0.5.0/writing-reactors/inputs-and-outputs"},next:{title:"Time and Timers",permalink:"/docs/0.5.0/writing-reactors/time-and-timers"}},y={},v=[{value:"Parameter Declaration",id:"parameter-declaration",level:2},{value:"State Declaration",id:"state-declaration",level:2},{value:"Reset State Variables",id:"reset-state-variables",level:2}];function b(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.Gv,{c:!0,cpp:!0,py:!0,rs:!0,ts:!0}),"\n",(0,a.jsx)(t.h2,{id:"parameter-declaration",children:"Parameter Declaration"}),"\n",(0,a.jsx)(t.p,{children:"A reactor class definition can parameterized as follows:"}),"\n",(0,a.jsxs)(s.Sk,{children:[(0,a.jsxs)(s.lr,{c:!0,cpp:!0,ts:!0,rs:!0,children:[(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lf",children:"reactor <class-name>(<param-name>:<type> = <expr>, ...) {\n    ...\n}\n"})}),(0,a.jsxs)(t.p,{children:["Each parameter has a ",(0,a.jsx)(t.em,{children:"type annotation"}),", written ",(0,a.jsx)(t.code,{children:":<type>"}),", where ",(0,a.jsx)(t.code,{children:"<type>"})," has one of the following forms:"]}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["An identifier, such as ",(0,a.jsx)(t.code,{children:"int"}),(0,a.jsxs)("span",{class:"lf-cpp",children:[", possibly followed by a type argument, e.g. ",(0,a.jsx)(t.code,{children:"vector<int>"})]}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["An array type ",(0,a.jsx)(t.code,{children:"type[]"}),(0,a.jsxs)("span",{class:"lf-c lf-cpp lf-rs",children:[" and ",(0,a.jsx)(t.code,{children:"type[integer]"})]}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["The keyword ",(0,a.jsx)(t.code,{children:"time"}),", which designates a time value."]}),"\n",(0,a.jsxs)(t.li,{children:["A code block delimited by ",(0,a.jsx)(t.code,{children:"{= ... =}"}),", where the contents is any valid type in the target language."]}),"\n"]}),(0,a.jsx)(s.Ae,{c:!0,cpp:!0,children:(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["A pointer type, such as ",(0,a.jsx)(t.code,{children:"int*"}),"."]}),"\n"]})}),(0,a.jsxs)(s.Ae,{c:!0,children:[(0,a.jsxs)(t.p,{children:["Types ending with a ",(0,a.jsx)(t.code,{children:"*"})," are treated specially by the C target. See the ",(0,a.jsx)(t.a,{href:"/docs/0.5.0/reference/target-language-details",children:"Target Language Details"}),"."]}),(0,a.jsxs)(t.p,{children:['To use strings conveniently in the C target, the "type" ',(0,a.jsx)(t.code,{children:"string"})," is an alias for ",(0,a.jsx)(t.code,{children:"{=const char*=}"}),"."]})]}),(0,a.jsx)(s.Ae,{ts:!0,children:(0,a.jsxs)(t.p,{children:["For example, ",(0,a.jsx)(t.code,{children:"{= int | null =}"})," defines nullable integer type in TypeScript."]})})]}),(0,a.jsx)(s.lr,{py:!0,children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lf",children:"reactor <class-name>(<param-name> = <expr>, ... ) {\n    ...\n}\n"})})})]}),"\n",(0,a.jsxs)(t.p,{children:["Depending on the target, the type may be a ",(0,a.jsx)(t.a,{href:"/docs/0.5.0/writing-reactors/generics",children:"generic type"}),", which means that the type is parameter determined at the time the reactor class is instantiated."]}),"\n",(0,a.jsxs)(t.p,{children:["Each parameter must have a ",(0,a.jsx)(t.em,{children:"default value"}),", written ",(0,a.jsx)(t.code,{children:"<param-name> = <expr>"}),". An expression may be a numeric constant, a string enclosed in quotation marks, a time value such as ",(0,a.jsx)(t.code,{children:"10 msec"}),", a list of values, or target-language code enclosed in ",(0,a.jsx)(t.code,{children:"{= ... =}"}),", for example. See ",(0,a.jsx)(t.a,{href:"/docs/0.5.0/reference/expressions",children:"Expressions"})," for full details on what expressions are valid."]}),"\n",(0,a.jsxs)(t.p,{children:["For example, the ",(0,a.jsx)(t.code,{children:"Double"})," reactor on the ",(0,a.jsx)(t.a,{href:"/docs/0.5.0/writing-reactors/inputs-and-outputs",children:"previous page"})," can be replaced with a more general parameterized reactor ",(0,a.jsx)(t.code,{children:"Scale"})," as follows:"]}),"\n","\n",(0,a.jsx)(s.UJ,{c:i,cpp:c,py:l,rs:o,ts:d,lf:!0}),"\n",(0,a.jsxs)(t.p,{children:["This reactor, given any input event ",(0,a.jsx)(t.code,{children:"x"})," will produce an output ",(0,a.jsx)(t.code,{children:"y"})," with value equal to the input scaled by the ",(0,a.jsx)(t.code,{children:"factor"})," parameter. The default value of the ",(0,a.jsx)(t.code,{children:"factor"})," parameter is 2, but this can be changed when the ",(0,a.jsx)(t.code,{children:"Scale"})," reactor is instantiated."]}),"\n",(0,a.jsxs)(t.p,{children:["Notice how, within the body of a reaction, the code accesses the parameter value. This is different for each target language. ",(0,a.jsxs)("span",{class:"lf-c",children:["In the C target, a ",(0,a.jsx)(t.code,{children:"self"})," struct is provided that contains the parameter values."]})]}),"\n",(0,a.jsx)(t.h2,{id:"state-declaration",children:"State Declaration"}),"\n",(0,a.jsx)(t.p,{children:"A reactor declares a state variable as follows:"}),"\n",(0,a.jsxs)(s.Sk,{children:[(0,a.jsx)(s.lr,{c:!0,cpp:!0,ts:!0,rs:!0,children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lf",children:"  state <name>:<type> = <value>\n"})})}),(0,a.jsx)(s.lr,{py:!0,children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lf",children:"  state <name> = <value>\n"})})})]}),"\n",(0,a.jsx)(t.p,{children:"The type can be any of the same forms as for a parameter."}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"<value>"})," is an initial value and, like parameter values, can be given as an ",(0,a.jsx)(t.a,{href:"/docs/0.5.0/reference/expressions",children:"expression"})," or target language code with delimiters ",(0,a.jsx)(t.code,{children:"{= ... =}"}),". The initial value can also be given as a parameter name. The value can be accessed and modified in a target-language-dependent way as illustrated by the following example:"]}),"\n","\n",(0,a.jsx)(s.UJ,{c:h,cpp:p,py:u,rs:x,ts:m,lf:!0}),"\n",(0,a.jsxs)(t.p,{children:["This reactor has an integer state variable named ",(0,a.jsx)(t.code,{children:"count"}),", and each time its reaction is invoked, it outputs the value of that state variable and increments it. The reaction is triggered by a ",(0,a.jsx)(t.code,{children:"timer"}),", discussed in the next section."]}),"\n",(0,a.jsx)(t.h2,{id:"reset-state-variables",children:"Reset State Variables"}),"\n",(0,a.jsxs)(s.Sk,{children:[(0,a.jsx)(s.lr,{cpp:!0,ts:!0,rs:!0,children:(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"reset"})," keyword is not supported in $target-language$ because ",(0,a.jsx)(t.a,{href:"/docs/0.5.0/writing-reactors/modal-models",children:"modal reactors"})," are not supported."]})}),(0,a.jsxs)(s.lr,{c:!0,py:!0,children:[(0,a.jsxs)(t.p,{children:["A state variable declaration may be qualified with a ",(0,a.jsx)(t.code,{children:"reset"})," keyword as follows:"]}),(0,a.jsx)(s.UJ,{lf:!0,c:"reset state <name>:<type> = <value>",py:"reset state <name> = <value>"}),(0,a.jsxs)(t.p,{children:["When this is done, if the state variable or the reactor is within a mode of a ",(0,a.jsx)(t.a,{href:"/docs/0.5.0/writing-reactors/modal-models",children:"modal reactor"}),", then when the mode is entered via a reset transition, the state variable will be reset to its initial value. For details, see the ",(0,a.jsx)(t.a,{href:"/docs/0.5.0/writing-reactors/modal-models",children:"Modal Reactors"})," section."]})]})]})]})}function w(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(b,{...e})}):b(e)}}}]);