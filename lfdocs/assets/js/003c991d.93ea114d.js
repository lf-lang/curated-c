"use strict";(globalThis.webpackChunkdocusaurus_classic_typescript=globalThis.webpackChunkdocusaurus_classic_typescript||[]).push([[65632],{24713:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(74848),r=n(28453);const i={title:"Introduction",description:"Introduction to Lingua Franca.",slug:"/"},o=void 0,s={id:"introduction",title:"Introduction",description:"Introduction to Lingua Franca.",source:"@site/versioned_docs/version-0.7.0/introduction.md",sourceDirName:".",slug:"/",permalink:"/docs/0.7.0/",draft:!1,unlisted:!1,editUrl:"https://github.com/lf-lang/lf-lang.github.io/tree/master/versioned_docs/version-0.7.0/introduction.md",tags:[],version:"0.7.0",frontMatter:{title:"Introduction",description:"Introduction to Lingua Franca.",slug:"/"},sidebar:"handbookSidebar",next:{title:"Installation",permalink:"/docs/0.7.0/installation"}},c={},l=[{value:"Reactor-Oriented Programming",id:"reactor-oriented-programming",level:2},{value:"Getting Started",id:"getting-started",level:2}];function d(e){const t={a:"a",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Lingua Franca (LF) is a polyglot coordination language built to enrich mainstream target programming languages (currently C, C++, Python, TypeScript, and Rust) with deterministic reactive concurrency and the ability to specify timed behavior. LF is supported by a runtime system that is capable of concurrent and distributed execution of reactive programs that are deployable on the Cloud, the Edge, and even on bare-iron embedded platforms."}),"\n",(0,a.jsx)(t.p,{children:"A Lingua Franca program specifies the interactions between components called reactors. The logic of each reactor is written in plain target code. A code generator synthesizes one or more programs in the target language, which are then compiled using standard tool chains. If the application has exploitable parallelism, then it executes transparently on multiple cores without compromising determinacy. A distributed application translates into multiple programs and scripts to launch those programs on distributed machines. The communication fabric connecting components is synthesized as part of the programs."}),"\n",(0,a.jsx)(t.h2,{id:"reactor-oriented-programming",children:"Reactor-Oriented Programming"}),"\n",(0,a.jsxs)(t.p,{children:["Lingua Franca programs are compositions of reactors, which are stateful\ncomponents with event-triggered routines that may read inputs, write outputs, manipulate the reactor's state and schedule future events.\nReactors are similar to actors, software components that send each other messages, but unlike classical actors, messages are timestamped, and concurrent composition of reactors is deterministic by default. When nondeterministic interactions are tolerable or desired, they must be explicitly coded. LF itself is a polyglot composition language, not a complete programming language. LF describes the interfaces and composition of reactors. See our ",(0,a.jsx)(t.a,{href:"/research",children:"publications and presentations"})," on reactors and Lingua Franca."]}),"\n",(0,a.jsx)(t.p,{children:"The reactor-oriented programming paradigm is informally described via the following principles:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Components"})," \u2014 Reactors can have input ports, actions, and timers, all of which are triggers. They can also have output ports, local state, parameters, and an ordered list of reactions."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Composition"})," \u2014 A reactor may contain other reactors and manage their connections. The connections define the flow of messages, and two reactors can be connected if they are contained by the same reactor or one is directly contained in the other (i.e., connections span at most one level of hierarchy). An output port may be connected to multiple input ports, but an input port can only be connected to a single output port."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Events"})," \u2014 Messages sent from one reactor to another, and timer and action events each have a tag (i.e., a timestamp), a value on a logical time line. These are tagged events that can trigger reactions. Each port, timer, and action can have at most one such event at any tag. An event may carry a value that will be passed as an argument to triggered reactions."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Reactions"})," \u2014 A reaction is a procedure in a target language that is invoked in response to a trigger event, and only in response to a trigger event. A reaction can read input ports, even those that do not trigger it, and can produce outputs, but it must declare all inputs that it may read and output ports to which it may write. All inputs that it reads and outputs that it produces bear the same timestamp as its triggering event. I.e., the reaction itself is logically instantaneous, so any output events it produces are logically simultaneous with the triggering event (the two events bear the same timestamp)."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Flow of Time"})," \u2014 Successive invocations of any single reaction occur at strictly increasing tags. Any messages that are not read by a reaction triggered at the timestamp of the message are lost."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Mutual Exclusion"})," \u2014 The execution of any two reactions of the same reactor are mutually exclusive (atomic with respect to one another). Moreover, any two reactions that are invoked at the same tag are invoked in the order specified by the reactor definition. This avoids race conditions between reactions accessing the reactor state variables."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Determinism"})," \u2014 A Lingua Franca program is deterministic unless the programmer explicit uses nondeterministic constructs. Given the same input data, a composition of reactors has exactly one correct behavior. This makes Lingua Franca programs ",(0,a.jsx)(t.em,{children:"testable"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Concurrency"})," \u2014 Dependencies between reactions are explicitly declared in a Lingua Franca program, and reactions that are not dependent on one another can be executed in parallel on a multi-core machine. If the target provides a support for federated execution, then execution can also be distributed across networks."]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,a.jsxs)(t.p,{children:["To get started with Lingua Franca, ",(0,a.jsx)(t.a,{href:"/docs/0.7.0/installation",children:"set up a development environment"})," and learn how to write ",(0,a.jsx)(t.a,{href:"/docs/0.7.0/writing-reactors/a-first-reactor",children:"a first reactor"}),". There are also a number of useful ",(0,a.jsx)(t.a,{href:"/docs/0.7.0/tutorial-videos",children:"tutorial videos"})," available."]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var a=n(96540);const r={},i=a.createContext(r);function o(e){const t=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);